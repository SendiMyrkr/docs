[{"id":"\/tutorial\/introduction.html#1-1","title":"Introduction","content":"In the following pages, we will walk through all prooph components step by step and take a look at how they work together. You will learn the basic concepts as well as some advanced techniques to push your PHP applications to the next level and prepare them for the future."},{"id":"\/tutorial\/introduction.html#1-1-1","title":"Objectives of This Tutorial","content":"In the prooph ecosystem everything is bound together by messages, so when you want to get started with prooph components you should know the basic building block - prooph messages. Once you know how they work, we give a short overview of CQRS and Event Sourcing and why messages play an important role in this architecture."},{"id":"\/tutorial\/introduction.html#1-1-2","title":"The Initial Setup","content":"To start with the tutorial you need PHP 7.1 and composer installed. If you're on Windows please consider using a Linux VM for the tutorial. The tutorial is tested on Linux only and the commands needed for project set up (not many) are shown in their Linux version only."},{"id":"\/tutorial\/introduction.html#1-1-3","title":"Prooph Messages","content":"Every prooph component deals with messages in one way or another, so we've put them in a common package.Let's get our hands dirty and install the package. First, create an empty folder called prooph_tutorial and cd into it."},{"id":"\/tutorial\/introduction.html#1-1-3-1","title":"Require prooph\/common","content":"$ composer require prooph\/commonThis command will run composer, generating a fresh composer.json for us, adding prooph\/common as the first package to our new project."},{"id":"\/tutorial\/introduction.html#1-1-3-2","title":"The first message","content":"Create a file called hello_world.php with the following content and run it with php:&lt;?php \/\/All prooph components enable strict types declare(strict_types=1); namespace Prooph\\Tutorial; use Prooph\\Common\\Messaging\\Command; use Prooph\\Common\\Messaging\\PayloadConstructable; use Prooph\\Common\\Messaging\\PayloadTrait; \/\/Require composer's autoloader require 'vendor\/autoload.php'; \/\/Our first message final class SayHello extends Command implements PayloadConstructable { use PayloadTrait; public function to(): string { return $this-&gt;payload['to']; } } $sayHello = new SayHello(['to' =&gt; 'World']); echo 'Hello ' . $sayHello-&gt;to(); \/\/Hello World In the script above we created our first message of type Command. We also used Prooph\\Common\\Messaging\\PayloadTrait in conjunction with the Prooph\\Common\\Messaging\\PayloadConstructable interface to instantiating our command with a payload - a simple array - and get access to it using $this-&gt;payload within the message. While this is a very easy and fast way to create message classes it is completely optional. The most important thing to note here is that Prooph\\Common\\Messaging\\Command implements Prooph\\Common\\Messaging\\Message&lt;?php declare(strict_types=1); namespace Prooph\\Common\\Messaging; use DateTimeImmutable; use Ramsey\\Uuid\\Uuid; interface Message extends HasMessageName { public const TYPE_COMMAND = 'command'; public const TYPE_EVENT = 'event'; public const TYPE_QUERY = 'query'; \/** * Should be one of Message::TYPE_COMMAND, Message::TYPE_EVENT or Message::TYPE_QUERY *\/ public function messageType(): string; public function uuid(): Uuid; public function createdAt(): DateTimeImmutable; public function payload(): array; public function metadata(): array; public function withMetadata(array $metadata): Message; \/** * Returns new instance of message with $key =&gt; $value added to metadata * * Given value must have a scalar or array type. *\/ public function withAddedMetadata(string $key, $value): Message; } The basic contract defines an immutable message with a unique identifier, a type, a created at timestamp, a message name (by extending the HasMessageName interface), payload and metadata. Payload should only contain scalar types and arrays (no objects) and metadata only scalars to be truly immutable."},{"id":"\/tutorial\/introduction.html#1-1-4","title":"Command Query Responsibility Segregation","content":"Command Query Responsibility Segregation (CQRS for short), first described by Greg Young, is one of the two main patterns we created the prooph components to implement. Our goal is to port his idea to the PHP world and make it easy to use for PHP developers.To summarize CQRS in one sentence:A CQRS system is divided into two parts, a write model to handle all state changes and a read model to query that state.The basic concept is very simple and can be illustrated by a common service class:&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class UserService { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function createUser(int $id, string $name, string $email): User { $user = new User($id); $user-&gt;setName($name); $user-&gt;setEmail($email); $this-&gt;userRepository-&gt;save($user); return $user; } public function getUser(int $id): User { $user = $this-&gt;userRepository-&gt;get($id); if(!$user) { throw UserNotFoundException::withId($id); } return $user; } } The UserService is responsible for all actions related to a user. In a CQRS system this looks slightly different:CreateUserHandler.php&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class CreateUserHandler { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function createUser(int $id, string $name, string $email): void { $user = new User($id); $user-&gt;setName($name); $user-&gt;setEmail($email); $this-&gt;userRepository-&gt;save($user); } } UserFinder.php&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class UserFinder { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function getUser(int $id): User { $user = $this-&gt;userRepository-&gt;get($id); if(!$user) { throw UserNotFoundException::withId($id); } return $user; } } Instead of one service, we have two separate services one for handling the write action and one for handling the query. Note that CreateUserHandler::createUser(): void no longer returns the new user object. The method signature follows a basic rule of CQRS: Write operations don't have a return valueWhile this looks like overkill, it enables you to design write and read sides independent of each other. Let's look at a read-optimized UserFinder&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class UserFinder { private $connection; public function __construct(Connection $connection) { $this-&gt;connection = $connection; } public function getUser(int $id): array { $userData = $this-&gt;connection-&gt;findOneBy(['id' =&gt; $id]); if(!$userData) { throw UserNotFoundException::withId($id); } return $userData; } } We no longer use the UserRepository but instead directly access the database. So we avoid the object relational mapping and return pure user data from our finder. We can do this because we know that our read model won't do anything with the data other than forwarding it to a client that, for example, requires the data in JSON or XML format. If it is guaranteed that no state changes happen within the read model, we don't need to deal with objects as we don't need to enforce any rules. Select the data and return it to the client as fast as possible that is the target of the read model.The write model, however, has to protect invariants. At the moment our user object does a bad job of this.$user = new User($id); $user-&gt;setName($name); $user-&gt;setEmail($email); These three lines tell us that a User can exist in our system without a name and an email, only the id is required. For most systems this is not true. What about this?$user = User::create($id, $name, $email); Yeah, looks better now. Let's put it in the handler.&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class CreateUserHandler { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function createUser(int $id, string $name, string $email): void { $user = User::create($id, $name, $email); $this-&gt;userRepository-&gt;save($user); } } It is okay but not perfect because we are missing intent. The code does not express why a user is created.The following code looks better, right?&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class RegisterUserHandler { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function registerUser(int $id, string $name, string $email): void { $user = User::register($id, $name, $email); $this-&gt;userRepository-&gt;save($user); } } Finally, we add some prooph flavour and change the method of the handler to handle a prooph message&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class RegisterUserHandler { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function handle(RegisterUser $command): void { $user = User::register($command-&gt;userId(), $command-&gt;userName(), $command-&gt;email()); $this-&gt;userRepository-&gt;save($user); } } With a few changes we turned our original UserService into two distinct classes supporting the basic idea of CQRS. In the last step we enabled the write side to handle a prooph command that expresses its intent of how the system state should change (a new user should be registered) using the message name, RegisterUser, and payload of the command. The RegisterUserHandler is a so-called glue component. Its task is to take the command and translate the intent into an action performed by the write model (in our case the user). Finally, the command handler makes use of the infrastructure (represented by the UserRepository) to persist the state change caused by the command."},{"id":"\/tutorial\/introduction.html#1-1-5","title":"Event Sourcing","content":"In an event sourced system all state changes are described by events. The fact that a new user was registered in our system would be one of those events. Another one would be that the user has logged in or changed their email address.Let's analyze the last example. We start by looking at our database table after the user was registered. id name email 1 John Doe doe@test.com Applying CQRS again we end up with a new command ChangeEmail, an appropriate command handler and a matching action in the write model owned by the responsible object User::changeEmail&lt;?php declare(strict_types = 1); namespace Prooph\\Tutorial; class ChangeEmailHandler { private $userRepository; public function __construct(UserRepository $repository) { $this-&gt;userRepository = $repository; } public function handle(ChangeEmail $command): void { $user = $this-&gt;userRepository-&gt;get($command-&gt;userId()); $user-&gt;changeEmail($command-&gt;newEmail()); $this-&gt;userRepository-&gt;save($user); } } Performing a command like this:$changeEmail = new ChangeEmail([ 'userId' =&gt; 1, 'newEmail' =&gt; 'john.doe@test.com' ]); $handler-&gt;handle($changeEmail); will result in an updated database row id name email 1 John Doe john.doe@test.com What is wrong here? We've changed state but we don't know why and when it happened. Wouldn't it be nice if we could look at the database and see what caused the state change?What would you say if your database would give you this information instead?[{ event: UserWasRegistered, createdAt: 2017-01-13 payload: {id: 1, name: \"John Doe\", email: \"doe@test.com\"} }, { event: EmailWasChanged, createdAt: 2017-01-14 payload: {id: 1, newEmail: \"john.doe@test.com\"} }] Welcome to the world of Event Sourcing. This is only the beginning. After completing the walk-through tutorial, you won't want to look back. Event Sourcing makes it so much simpler to create software that reflects intent, and you have all information available to find bugs faster and add new features without pain. Messages are the basic building block but we need to look at a few other things. Fasten your seatbelt and enjoy the journey."},{"id":"\/tutorial\/introduction.html#1-1-6","title":"Quick Version","content":"The following pages cover everything you need to know about Event Sourcing, including detailed explanations and working on an example project. If you want to do a quick walk-through instead, or get your hands dirty before the theory, then you can head over to Prooph: CQRS+ES in PHP. How to use. - by Marcin Pil\u00c5\u009bniak."},{"id":"\/tutorial\/why_event_sourcing.html#1-2","title":"Why Event Sourcing?","content":"Event Sourcing is a fascinating topic, but the learning curve is steep. This is not because Event Sourcing is a complex pattern but because it conflicts with our current understanding of data-centric object-oriented programming. This understanding is driven by the way we work with databases, mostly relational databases but it is not limited to them.Our primary goal is to put consistent data into a database and keep it consistent. A common way is to normalize the data, and this is where the problem starts.Mapping the real world to a normalized view is a complex task, and we tend to do it before we do anything else. Business describes a new feature, and we immediately think of a possible data structure that fits into our favorite database design. We can share this thinking with our teammates because every programmer did the same thing in their head already. We can simply match results and are good to go, right?Well, not really. Often, the first draft of a data structure does not work as expected, so we have to reshape it and try again. And not to forget this shitty real world, no one wants to view normalized data, so we have to write queries and make heavy use of joins. Then we recognize that fetching the data with joins is inefficient, and we use caches and other techniques to work around the limitation instead of solving the problem in the first place!But that's not all. The worst part of this approach is that we design our application logic around data and not around behaviour.We skip the behaviour part of the feature description, turn the feature into our own view of normalized state, and then reverse engineer behaviour.It's not hard to imagine that this approach leads to an application design driven by the database, so it is a technical design that does not match the original business idea. If you think this is the best way to tackle software complexity, then you should probably stop reading, because you won't have any fun with Event Sourcing.If you cannot get rid of the feeling that there is something inherently wrong with database driven designs, then you should read on, follow the tutorial, and, slowly but surely, become a software developer focused on real business behaviour.Event Sourcing has many advantages in modern systems: coordinating work across different services, solving performance and concurrency problems, and many more.But the most important advantage of Event Sourcing is the focus on behaviour."},{"id":"\/tutorial\/event_sourcing_basics.html#1-3","title":"Event Sourcing Basics","content":"Event Sourcing focuses on business processes. Every write operation in a domain model causes a state change, described by a domain event. For example, an order getting paid is a state change (company gets $$$), and we can describe it with an event using past tense: OrderPaid. We do that for all state changes, and what we get is a series of domain events\u00c2\u00b9.Events happen sequentially. They tell us a story about a business process handled by the application."},{"id":"\/tutorial\/event_sourcing_basics.html#1-3-1","title":"Thinking in Events","content":"The previous page, \"Why Event Sourcing\", made a point about database driven designs and how Event Sourcing differs from that. In Event Sourcing, we start with thinking in events.Every coding tutorial needs a playground. Ours is an eCommerce domain, and our first job is to implement a shopping basket. Business tells us that customers can browse an online shop frontend and add available products to their basket. The customers don't need to be signed in, so their basket is assigned to a shopping session until checkout. So far, so good. But the business wants us to implement realtime stock updates. While browsing the online shop, customers should see constantly updated information about how many other customers have the same products in their basket: \"5 other customers want to buy the same product, at the moment\". If one customer performs a checkout, stock of the product should be reduced immediately, along with a notification: \"Product {name} was bought by a customer from {localization} {time span} ago\".Here is a simplified result of the event storming\u00c2\u00b2 session:As you can see, we have a variety of different events. Not only do we have events that are caused by the customer while interacting with their shopping basket but also events caused by changes in other customers' shopping sessions. We even have two \"error events\" defined: QuantityStockConflictDetected, ShoppingSessionTimedOut."},{"id":"\/tutorial\/event_sourcing_basics.html#1-3-2","title":"Defining Events","content":"In the tutorial introduction we looked at prooph messages and created our first command. Events are just another type of message; hence, each prooph event is an implementation of Prooph\\Common\\Messaging\\Message.If you do not have the prooph_tutorial project at hand with prooph\/common installed, please go back to the introduction and follow the steps there before continuing with the Event Sourcing tutorial.We need a project structure for our shopping basket implementation.|_ Basket | |_ scripts | |_ src | | |_ Infrastructure | | | |_ Prooph | | |_ Model | | | |_ Basket | | | |_ Command | | | |_ Event | | | |_ ERP | | | |_ Exception | | |_ Projection | | |_ Query | |_ tests | |_Model |_ scripts Run the following command in the prooph_tutorial directory.$ mkdir -p .\/Basket\/src\/Infrastruture\/Prooph \\ .\/Basket\/src\/Model\/Command\/ \\ .\/Basket\/src\/Model\/Event\/ \\ .\/Basket\/src\/Model\/Basket\/ \\ .\/Basket\/src\/Model\/ERP\/ \\ .\/Basket\/src\/Model\/Exception\/ \\ .\/Basket\/src\/Projection\/Query \\ .\/Basket\/tests\/Model \\ .\/scripts Replace composer.json with this version and run composer update:{ \"autoload\": { \"psr-4\": {\"App\\\\Basket\\\\\": \"Basket\/src\/\"} }, \"autoload-dev\": { \"psr-4\": {\"App\\\\BasketTest\\\\\": \"Basket\/tests\/\"} }, \"require\": { \"prooph\/common\": \"^4.1\", \"prooph\/event-sourcing\": \"^5.2\" }, \"require-dev\": { \"phpunit\/phpunit\": \"^6.0\" } } We just configured composer's autoloader to use the namespace App\\Basket for our Basket context and the appropriate test namespace App\\BasketTest. We've also added the package prooph\/event-sourcing to the list of dependencies and told composer to install phpunit\/phpunit when we're in dev mode.You can guess that prooph\/event-sourcing provides the basic implementation needed to develop an event sourced domain model.Now it's time to define our first domain event. We place all events in .\/Basket\/src\/Model\/Event\/File: .\/Basket\/src\/Model\/Event\/ShoppingSessionStarted.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Event; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\Basket\\ShoppingSession; use Prooph\\EventSourcing\\AggregateChanged; final class ShoppingSessionStarted extends AggregateChanged { public function basketId(): BasketId { \/\/Note: Internally, we work with scalar types, but the getter returns the value object return BasketId::fromString($this-&gt;aggregateId()); } public function shoppingSession(): ShoppingSession { \/\/Same here, return domain specific value object return ShoppingSession::fromString($this-&gt;payload['shopping_session']); } } Here we extend the base event class AggregateChanged from the prooph\/event-sourcing package. We will discuss aggregates more in a minute, but, first, let's have a look at what the base event class has to offer:&lt;?php declare(strict_types=1); namespace Prooph\\EventSourcing; use Assert\\Assertion; use Prooph\\Common\\Messaging\\DomainEvent; class AggregateChanged extends DomainEvent { \/** * @var array *\/ protected $payload = []; public static function occur(string $aggregateId, array $payload = []): self { return new static($aggregateId, $payload); } \/\/... } AggregateChanged extends Prooph\\Common\\Messaging\\DomainEvent. That's the link back to prooph\/common and turns all events into prooph messages. Keep that in mind, as this is important later when we want to send events around.We also see a static factory method called occur that takes an $aggregateId and $payload as arguments. The $aggregateId is a reference to the corresponding aggregate. Every domain event belongs to exactly one aggregate."},{"id":"\/tutorial\/event_sourcing_basics.html#1-3-3","title":"Event Sourced Aggregates","content":"Event Sourced Aggregates are Domain-Driven Aggregates, representing a unit of consistency. They protect invariants. This basically means that an aggregate makes sure that it can transition to a new state. Different business rules can permit or prevent state transitions, and the aggregate has to enforce these business rules.In our case we need to consider the following business rules: A shopping session starts with an empty basket. Each shopping session is assigned its own basket. A product can only be added to a basket if at least one product is available in stock. Product quantity in a basket must not be higher than available stock. If stock is reduced by a checkout, product quantity in currently active baskets needs to be checked and conflicts resolved. If product quantity in a basket is reduced to zero or less the product is removed from the basket. A checkout can only be made if no unresolved quantity-stock-conflicts exist for the basket. Looking at the rules we can identify a repeating pattern. Every rule includes a state check against a basket and\/or describes a state transition of a basket. With our current understanding of the domain, we're good to go with a Basket aggregate that enforces the business rules described above.Even if we name our aggregate Basket, you can think of it as if it were named BasketProcess. We don't do it that way because it does not reflect the Ubiquitous Language\u00c2\u00b3 which we draw from the language used by the business. However, when implementing Event Sourcing you can always keep that Process suffix in mind.Recap: Every state transition is described by an event. Events happen one after another. They tell us a story about a business process. An aggregate is a process consisting of multiple steps happening in a sequence; whereby, each next step is validated by the aggregate upfront using current state:A checkout can only be made if no unresolved quantity-stock-conflicts exist for the basket.Effective Aggregate Design\u00c2\u00b9\u00c2\u00b9 is possibly the hardest part of a well crafted domain model. And it evolves over time so be prepared to constantly refactor previous design decisions. Thinking of aggregates as processes and modeling them in an event sourced fashion can help a lot, but it remains a task that needs practice. So don't worry if your first attempts end up being unpractical. You will get better. Thinking in events and processes is the key.Let's add the Basket aggregate now.File: .\/Basket\/src\/Model\/Basket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model; use Prooph\\EventSourcing\\AggregateChanged; use Prooph\\EventSourcing\\AggregateRoot; final class Basket extends AggregateRoot { protected function aggregateId(): string { \/\/ TODO: Implement aggregateId() method. } \/** * Apply given event *\/ protected function apply(AggregateChanged $event): void { \/\/ TODO: Implement apply() method. } } Our Basket class extends Prooph\\EventSourcing\\AggregateRoot. This is the base class for all event sourced aggregates. Later we'll also look at an alternative approach using traits instead of extending a prooph class, but the version shown here is easier to understand and helps us with the first steps. AggregateRoot is an abstract class and asks us to implement two methods aggregateId(), which should provide the string representation of the globally unique identifier of the aggregate, and an apply() method.The apply() method is best explained with an example so let us dive into the implementation. Each aggregate has a lifecycle. To start such a lifecycle we need to create the aggregate. But prooph's AggregateRoot does not allow creating the class constructor as a public method. Instead, we're asked to use a so-called named constructor, aka static factory method.File: .\/Basket\/src\/Model\/Basket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model; use App\\Basket\\Model\\Event\\ShoppingSessionStarted; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\Basket\\ShoppingSession; use Prooph\\EventSourcing\\AggregateChanged; use Prooph\\EventSourcing\\AggregateRoot; final class Basket extends AggregateRoot { public static function startShoppingSession( ShoppingSession $shoppingSession, BasketId $basketId) { \/\/Start new aggregate lifecycle by creating an \"empty\" instance $self = new self(); \/\/Record the very first domain event of the new aggregate \/\/Note: we don't pass the value objects directly to the event but use their \/\/primitive counterparts. This makes it much easier to work with the events later \/\/and we don't need complex serializers when storing events. $self-&gt;recordThat(ShoppingSessionStarted::occur($basketId-&gt;toString(), [ 'shopping_session' =&gt; $shoppingSession-&gt;toString() ])); \/\/Return the new aggregate return $self; } protected function aggregateId(): string { \/\/ TODO: Implement aggregateId() method. } \/** * Apply given event *\/ protected function apply(AggregateChanged $event): void { \/\/ TODO: Implement apply() method. } } A meaningfully named constructor using the Ubiquitous Language is a great way to let the code document itself. The Basket aggregate requires a ShoppingSession and a BasketId to start the shopping session. Both are value objects that we're going to add next.Note: BasketId becomes the identifier of the aggregate but it is created outside of the aggregate. That's a common pattern in a CQRS system. For example the frontend can create a BasketId using a JavaScript UUID library and send the BasketId to the backend. Remember from the introduction chapter: Handling a command has no response other than success or failure. In case of success, the frontend can use the BasketId to fetch state of the Basket from a read model. Later in the tutorial we'll see that in action. For now, just keep in mind that aggregate ids are created by the client or application layer if a CQRS architecture is used.File: .\/Basket\/src\/Model\/Basket\/ShoppingSession.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Basket; final class ShoppingSession { private $shoppingSession; public static function fromString(string $shoppingSession): self { return new self($shoppingSession); } private function __construct(string $shoppingSession) { if($shoppingSession === '') { throw new \\InvalidArgumentException(\"Shopping session must not be an empty string\"); } $this-&gt;shoppingSession = $shoppingSession; } public function toString(): string { return $this-&gt;shoppingSession; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;shoppingSession === $other-&gt;shoppingSession; } public function __toString(): string { return $this-&gt;shoppingSession; } } File: .\/Basket\/src\/Model\/Basket\/BasketId.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Basket; use Ramsey\\Uuid\\Uuid; final class BasketId { private $basketId; public static function fromString(string $basketId): self { return new self($basketId); } private function __construct(string $basketId) { if(!Uuid::isValid($basketId)) { throw new \\InvalidArgumentException(\"Given basket id is not a valid UUID. Got \" . $basketId); } $this-&gt;basketId = $basketId; } public function toString(): string { return $this-&gt;basketId; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;basketId === $other-&gt;basketId; } public function __toString(): string { return $this-&gt;basketId; } } Recap: We used a named constructor to create the Basket aggregate. The named constructor defines the requirements needed to start a shopping session, namely the ShoppingSession and BasketId. Instead of setting those value objects as properties in the Basket aggregate we record the first domain event, ShoppingSessionStarted, of the aggregate.Now the apply() method comes into play. Our Basket aggregate will have many more methods later to deal with all the things happening during a shopping session, and in those methods we will often need the current state of the aggregate to protect invariants. To get access to the state we need to apply() recorded domain events in the exact same order as they were recorded. Prooph's AggregateRoot takes care of the latter but it does not know how a domain event should be applied. Hence, we need to take over that task.File: .\/Basket\/src\/Model\/Basket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model; use App\\Basket\\Model\\Event\\ShoppingSessionStarted; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\Basket\\ShoppingSession; use Prooph\\EventSourcing\\AggregateChanged; use Prooph\\EventSourcing\\AggregateRoot; final class Basket extends AggregateRoot { \/** * @var BasketId *\/ private $basketId; \/** * @var ShoppingSession *\/ private $shoppingSession; public static function startShoppingSession(ShoppingSession $shoppingSession, BasketId $basketId) { $self = new self(); $self-&gt;recordThat(ShoppingSessionStarted::occur($basketId-&gt;toString(), [ 'shopping_session' =&gt; $shoppingSession-&gt;toString() ])); return $self; } protected function aggregateId(): string { \/\/ TODO: Implement aggregateId() method. } \/** * Apply given event *\/ protected function apply(AggregateChanged $event): void { \/\/A simple switch by event name is the fastest way, \/\/but you're free to split things up here and have, for example, methods like \/\/private function whenShoppingSessionStarted() \/\/To delegate work to them and keep the apply method lean switch ($event-&gt;messageName()) { case ShoppingSessionStarted::class: \/** @var $event ShoppingSessionStarted *\/ $this-&gt;basketId = $event-&gt;basketId(); $this-&gt;shoppingSession = $event-&gt;shoppingSession(); break; } } } Now that we have access to the current state, we can finally implement the aggregateId() method to fulfill the contract defined by prooph's AggregateRoot class.File: .\/Basket\/src\/Model\/Basket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model; \/\/... final class Basket extends AggregateRoot { \/** * @var BasketId *\/ private $basketId; \/** * @var ShoppingSession *\/ private $shoppingSession; public static function startShoppingSession(ShoppingSession $shoppingSession, BasketId $basketId) { \/\/... } protected function aggregateId(): string { \/\/Return string representation of the globally unique identifier of the aggregate return $this-&gt;basketId-&gt;toString(); } \/** * Apply given event *\/ protected function apply(AggregateChanged $event): void { \/\/... } } Ok, those are the basics of Event Sourcing. Many new things to learn, right? But don't worry. You'll get used to it while we look at some more aspects of Event Sourcing. In the next part we will look at testing event sourced aggregates, which is super easy when you have a clean and decoupled domain model.Advice: Revisit the basics part whenever you feel lost. Event Sourcing is really simple once you understand it. In the section below you will find links to related blog posts. Before you follow them, take a break and let the basics sink in. You can read the posts later when you feel more comfortable with Event Sourcing. Don't overload your head with too much information at once."},{"id":"\/tutorial\/event_sourcing_basics.html#1-3-4","title":"Related reads","content":" Domain Events - Mathias Verraes\u00c2\u00b9 What is EventStorming - Alberto Brandolini\u00c2\u00b2 Ubiquitous Language - Martin Fowler\u00c2\u00b3 Effective Aggregate Design - Vaughn Vernon\u00c2\u00b9\u00c2\u00b9 "},{"id":"\/tutorial\/testing_aggregates.html#1-4","title":"Testing Aggregates","content":"Event Sourcing makes it easy to test aggregates. In this chapter we will learn why. Don't underestimate this advantage. Easy testability is crucial for long-lived applications that evolve over time."},{"id":"\/tutorial\/testing_aggregates.html#1-4-1","title":"Test Recorded Events","content":"When testing an event sourced aggregate we only need to test two things: Does the aggregate record the correct domain event(s)? Does the aggregate either reject an action or record a failed event if a business rule is not met? The fact that an aggregate is event sourced is hidden from the public API. If we want to test recorded events, we need a test helper to get them from the aggregate. prooph\/event-sourcing uses a so-called AggregateTranslator to perform operations on protected methods of an aggregate. We can use the AggregateTranslator for our tests, too. Add a project TestCase class that includes some helper methods which we can use in our test cases.File: .\/Basket\/tests\/TestCase.php&lt;?php declare(strict_types=1); namespace App\\BasketTest; use PHPUnit\\Framework\\TestCase as PHPUnitTestCase; use Prooph\\EventSourcing\\Aggregate\\AggregateType; use Prooph\\EventSourcing\\AggregateRoot; use Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator; class TestCase extends PHPUnitTestCase { \/** * @var AggregateTranslator *\/ private $aggregateTranslator; protected function popRecordedEvents(AggregateRoot $aggregateRoot): array { return $this-&gt;getAggregateTranslator()-&gt;extractPendingStreamEvents($aggregateRoot); } \/** * @return object *\/ protected function reconstituteAggregateFromHistory(string $aggregateRootClass, array $events) { return $this-&gt;getAggregateTranslator()-&gt;reconstituteAggregateFromHistory( AggregateType::fromAggregateRootClass($aggregateRootClass), new \\ArrayIterator($events) ); } private function getAggregateTranslator(): AggregateTranslator { if (null === $this-&gt;aggregateTranslator) { $this-&gt;aggregateTranslator = new AggregateTranslator(); } return $this-&gt;aggregateTranslator; } } The same TestCase is used in the example application, proophessor-do\u00c2\u00b9. Besides the popRecordedEvents method we've also added a reconstituteAggregateFromHistory method. With the latter we can prepare an aggregate for a test case just using events, so we can \"move\" the aggregate to a certain point in the business process and start testing from there. This is really powerful and, as an added benefit, also self documenting. We'll see that in a minute.In the \"Event Sourcing Basics\" chapter we implemented the Basket::startShoppingSession() method. Let's test it now with a BasketTest.File: .\/Basket\/tests\/Model\/BasketTest.php&lt;?php declare(strict_types=1); namespace App\\BasketTest\\Model; use App\\Basket\\Model\\Basket; use App\\Basket\\Model\\Event\\ShoppingSessionStarted; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\Basket\\ShoppingSession; use App\\BasketTest\\TestCase; use Prooph\\EventSourcing\\AggregateChanged; use Ramsey\\Uuid\\Uuid; class BasketTest extends TestCase { \/** * @var ShoppingSession *\/ private $shoppingSession; \/** * @var BasketId *\/ private $basketId; protected function setUp() { $this-&gt;shoppingSession = ShoppingSession::fromString('123'); $this-&gt;basketId = BasketId::fromString(Uuid::uuid4()-&gt;toString()); } \/** * @test *\/ public function it_starts_a_shopping_session() { $basket = Basket::startShoppingSession($this-&gt;shoppingSession, $this-&gt;basketId); \/** @var AggregateChanged[] $events *\/ $events = $this-&gt;popRecordedEvents($basket); $this-&gt;assertCount(1, $events); \/** @var ShoppingSessionStarted $event *\/ $event = $events[0]; $this-&gt;assertSame(ShoppingSessionStarted::class, $event-&gt;messageName()); $this-&gt;assertTrue($this-&gt;basketId-&gt;equals($event-&gt;basketId())); $this-&gt;assertTrue($this-&gt;shoppingSession-&gt;equals($event-&gt;shoppingSession())); } } The two value objects needed to start a shopping session are created in the setUp() method of the test case. This way we get fresh objects for each test without needing to create them manually in each test method.To run the test, we need to tell PHPUnit where to find our test cases and how to use composer autoloader to locate the domain model. Just put a phpunit.xml.dist file in the project root with the following content:File: .\/phpunit.xml.dist&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;phpunit bootstrap=\"vendor\/autoload.php\"&gt; &lt;testsuites&gt; &lt;testsuite name=\"BasketModel\"&gt; &lt;directory&gt;.\/Basket\/tests&lt;\/directory&gt; &lt;\/testsuite&gt; &lt;\/testsuites&gt; &lt;\/phpunit&gt; Now we can run the tests with php vendor\/bin\/phpunit$ php vendor\/bin\/phpunit PHPUnit 6.3.1 by Sebastian Bergmann and contributors. . 1 \/ 1 (100%) Time: 20 ms, Memory: 4.00MB OK (1 test, 4 assertions) Nice, a green test. That's a good feeling, isn't it? Half a year later the feeling is even better when we have hundreds of green tests and need to refactor something in the domain model. So do yourself and your colleagues a favor and test the domain model!"},{"id":"\/tutorial\/testing_aggregates.html#1-4-2","title":"Reconstitute From History","content":"For the first test, we did not need the reconstituteAggregateFromHistory() test helper, but if we add more behaviour to the Basket aggregate, the test helper becomes quite handy. To see the test helper in action we're going to add a second method to the Basket aggregate that allows us to add a Product.We start simple in this chapter and leave a more complex implementation to the next chapter, \"Aggregate Dependencies\". First we need a new value object to reference a Product. Products are not part of our domain but are manged by an external ERP system.File: .\/Basket\/src\/Model\/ERP\/ProductId.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\ERP; final class ProductId { private $id; public static function fromString(string $id): self { return new self($id); } private function __construct(string $id) { if($id === '') { throw new \\InvalidArgumentException(\"Product id must not be an empty string\"); } $this-&gt;id = $id; } public function toString(): string { return $this-&gt;id; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;id === $other-&gt;id; } public function __toString(): string { return $this-&gt;id; } } We need a new domain event, too.File: .\/Basket\/src\/Model\/Event\/ProductAddedToBasket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Event; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\ERP\\ProductId; use Prooph\\EventSourcing\\AggregateChanged; final class ProductAddedToBasket extends AggregateChanged { public function basketId(): BasketId { return BasketId::fromString($this-&gt;aggregateId()); } public function productId(): ProductId { return ProductId::fromString($this-&gt;payload()['product_id']); } } And finally we add a new method to the Basket aggregate that we're going to test in a few seconds.File: .\/Basket\/src\/Model\/Basket.php&lt;?php \/\/... use App\\Basket\\Model\\ERP\\ProductId; use App\\Basket\\Model\\Exception\\ProductAddedTwice; final class Basket extends AggregateRoot { \/\/... \/** * @var ProductId[] *\/ private $products = []; public static function startShoppingSession(ShoppingSession $shoppingSession, BasketId $basketId) { \/\/... } public function addProduct(ProductId $productId): void { if(array_key_exists($productId-&gt;toString(), $this-&gt;products)) { throw ProductAddedTwice::toBasket($this-&gt;basketId, $productId); } \/\/@TODO: Check stock $this-&gt;recordThat(ProductAddedToBasket::occur($this-&gt;basketId-&gt;toString(), [ 'product_id' =&gt; $productId-&gt;toString()] )); } \/\/... \/** * Apply given event *\/ protected function apply(AggregateChanged $event): void { switch ($event-&gt;messageName()) { case ShoppingSessionStarted::class: \/\/... case ProductAddedToBasket::class: \/** @var $event ProductAddedToBasket *\/ \/\/Use ProductId as index to avoid adding a product twice $this-&gt;products[$event-&gt;productId()-&gt;toString()] = $event-&gt;productId(); break; } } } We have a new $products property which is a list of ProductIds, where the string representation of the ProductId is also used as index. This way we can easily check if a product is added twice.The new addProduct() method takes a ProductId as an argument and records a new domain event ProductAddedToBasket, which then gets applied using a new case in the apply method.If a product is added twice, the method throws a ProductAddedTwice exception. Here is the implementation of that exception.File: .\/Basket\/src\/Model\/Exception\/ProductAddedTwice.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Exception; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\ERP\\ProductId; final class ProductAddedTwice extends \\RuntimeException { public static function toBasket(BasketId $basketId, ProductId $productId): self { return new self(sprintf( 'Product %s added twice to basket %s', $productId-&gt;toString(), $basketId-&gt;toString() )); } } Back to the test case. We want to see if our implementation works as expected.File: .\/Basket\/tests\/Model\/BasketTest.php&lt;?php declare(strict_types=1); namespace App\\BasketTest\\Model; use App\\Basket\\Model\\Basket; use App\\Basket\\Model\\ERP\\ProductId; use App\\Basket\\Model\\Event\\ProductAddedToBasket; use App\\Basket\\Model\\Event\\ShoppingSessionStarted; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\Basket\\ShoppingSession; use App\\BasketTest\\TestCase; use Prooph\\EventSourcing\\AggregateChanged; use Ramsey\\Uuid\\Uuid; class BasketTest extends TestCase { \/** * @var ShoppingSession *\/ private $shoppingSession; \/** * @var BasketId *\/ private $basketId; \/** * @var ProductId *\/ private $product1; protected function setUp() { $this-&gt;shoppingSession = ShoppingSession::fromString('123'); $this-&gt;basketId = BasketId::fromString(Uuid::uuid4()-&gt;toString()); $this-&gt;product1 = ProductId::fromString('A1'); } \/** * @test *\/ public function it_starts_a_shopping_session() { $basket = Basket::startShoppingSession($this-&gt;shoppingSession, $this-&gt;basketId); \/** @var AggregateChanged[] $events *\/ $events = $this-&gt;popRecordedEvents($basket); $this-&gt;assertCount(1, $events); \/** @var ShoppingSessionStarted $event *\/ $event = $events[0]; $this-&gt;assertSame(ShoppingSessionStarted::class, $event-&gt;messageName()); $this-&gt;assertTrue($this-&gt;basketId-&gt;equals($event-&gt;basketId())); $this-&gt;assertTrue($this-&gt;shoppingSession-&gt;equals($event-&gt;shoppingSession())); } \/** * @test *\/ public function it_adds_a_product() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted() ); $basket-&gt;addProduct($this-&gt;product1); \/** @var AggregateChanged[] $events *\/ $events = $this-&gt;popRecordedEvents($basket); $this-&gt;assertCount(1, $events); \/** @var ProductAddedToBasket $event *\/ $event = $events[0]; $this-&gt;assertSame(ProductAddedToBasket::class, $event-&gt;messageName()); $this-&gt;assertTrue($this-&gt;basketId-&gt;equals($event-&gt;basketId())); $this-&gt;assertTrue($this-&gt;product1-&gt;equals($event-&gt;productId())); } \/** * @test * @expectedException \\App\\Basket\\Model\\Exception\\ProductAddedTwice *\/ public function it_throws_exception_if_product_is_added_twice() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted(), $this-&gt;product1Added() ); \/\/Add same product again $basket-&gt;addProduct($this-&gt;product1); } \/** * Helper method to reconstitute a Basket from history * * With this helper we get better type hinting in the test methods * because type hint for reconstituteAggregateFromHistory() is only AggregateRoot * * @param AggregateChanged[] ...$events * @return Basket *\/ private function reconstituteBasketFromHistory(AggregateChanged ...$events): Basket { return $this-&gt;reconstituteAggregateFromHistory( Basket::class, $events ); } \/** * Test helper to create a ShoppingSessionStarted event * * If we need to change signature of the event later, we have a central place in the test case * where we can align the creation. * * @return ShoppingSessionStarted *\/ private function shoppingSessionStarted(): ShoppingSessionStarted { return ShoppingSessionStarted::occur($this-&gt;basketId-&gt;toString(), [ 'shopping_session' =&gt; $this-&gt;shoppingSession-&gt;toString() ]); } \/** * Test helper to create a ProductAddedToBasket event * * If we need to change signature of the event later, we have a central place in the test case * where we can align the creation. * * @return ProductAddedToBasket *\/ private function product1Added(): ProductAddedToBasket { return ProductAddedToBasket::occur($this-&gt;basketId-&gt;toString(), [ 'product_id' =&gt; $this-&gt;product1-&gt;toString() ]); } } Looks good.$ php vendor\/bin\/phpunit PHPUnit 6.3.1 by Sebastian Bergmann and contributors. ... 3 \/ 3 (100%) Time: 19 ms, Memory: 4.00MB OK (3 tests, 9 assertions) We covered two new possibilities. First, we learned how to reconstitute an aggregate from history. We also added a few basket specific test helpers to get better type hinting support and keep creation of events in a central place for easier refactoring.Second, we learned how to test exceptions. Using exceptions to communicate errors is not always the best choice. Another possibility is to use domain events for failure scenarios, too. Later in the tutorial we will see this in action and discuss the pros and cons of such an approach.Either way, testing failure cases where the aggregate records a failed event is not different from testing normal event recording. Reconstitute the aggregate to move it to a certain point in the business process, provoke the recording of a failure event, and test if the event was correctly recorded. It's as easy as that."},{"id":"\/tutorial\/testing_aggregates.html#1-4-3","title":"Links","content":" proophessor-do example app\u00c2\u00b9 "},{"id":"\/tutorial\/aggregate_dependencies.html#1-5","title":"Aggregate Dependencies","content":"In the previous chapters we learned that an aggregate protects invariants and records an event for each state transition. It then applies recorded events to its internal state and uses the state to validate if the next state transition can take place.But an aggregate cannot always rely solely on its internal state. Sometimes the aggregate needs to get information from somewhere else to make a decision. In this case the aggregate has a dependency to an external service and in this chapter we will learn how to give access to such a service and, of course, how to test it."},{"id":"\/tutorial\/aggregate_dependencies.html#1-5-1","title":"Method Injection","content":"You may have noticed that we left a @TODO Check stock in the Basket::addProduct() method. Products are handled in an external ERP system and we can request current stock of a product from that system. When implementing Domain-Driven Design, it is a common approach to integrate an external system by defining an interface for it in the domain model but move the implementation to the infrastucture layer. A good example of such an integration is shown in the PHP DDD Cargo Sample\u00c2\u00b9, where the Cargo domain makes use of an external GraphTraversalService. This is called Hexagonal Architecture or Ports &amp; Adapters\u00c2\u00b2.We want to use the same approach for the ERP system but limit the implementation to the interface only, as we don't have access to the ERP system right now and only know the interface specification. That's enough, though, because we can easily mock the ERP and use the interface to decouple our domain model from it.File: .\/Basket\/src\/Model\/ERP\/ERP.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\ERP; use App\\Basket\\Model\\Exception\\UnknownProduct; interface ERP { \/** * Get stock information for given product * * If stock information cannot be fetched from the ERP system * this method returns null. * * If product is not known by the ERP system this method must throw an UnknownProduct exception * * @param ProductId $productId * @return ProductStock|null * @throws UnknownProduct *\/ public function getProductStock(ProductId $productId): ?ProductStock; } The ERP interface defines a method getProductStock which takes a ProductId as an argument and returns a ProductStock value object or null in case the request failed. You may have noticed that we use value objects a lot. In fact everything except our Basket aggregate is modeled as a value object so far. It is a rule of thumb to model everything as value objects and only use an aggregate if the object really has a lifecycle in YOUR domain. Products have a lifecycle but in the ERP system and not in our basket domain. We only consume product data as read-only information. Hence, we are better off using value objects to represent different aspects of a product like its stock information.Having said this, let's add the value object.File: .\/Basket\/src\/Model\/ERP\/ProductStock.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\ERP; final class ProductStock { \/** * @var ProductId *\/ private $productId; \/** * @var int *\/ private $quantity; \/** * @var int *\/ private $version; public static function fromArray(array $data): self { return new self( ProductId::fromString($data['product_id'] ?? ''), $data['quantity'] ?? 0, $data['version'] ?? 0 ); } private function __construct(ProductId $productId, int $quantity, int $version) { $this-&gt;productId = $productId; $this-&gt;quantity = $quantity; $this-&gt;version = $version; } \/** * @return ProductId *\/ public function productId(): ProductId { return $this-&gt;productId; } \/** * @return int *\/ public function quantity(): int { return $this-&gt;quantity; } \/** * @return int *\/ public function version(): int { return $this-&gt;version; } public function toArray(): array { return [ 'product_id' =&gt; $this-&gt;productId-&gt;toString(), 'quantity' =&gt; $this-&gt;quantity, 'version' =&gt; $this-&gt;version ]; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;toArray() === $other-&gt;toArray(); } public function __toString(): string { return json_encode($this-&gt;toArray()); } } ProductStock gives us two important pieces of information: stock quantity a version Stock quantity is self-explanatory, and the version is related to that quantity. Whenever stock quantity of a product changes, the version is increased by one. We can use the version during checkout to verify if the last known quantity of the product is still valid or if the quantity known by the basket is out-of-date.We also need a new UnknownProduct exception which is thrown by the ERP adapter in case the ERP system returns a not found response.File: .\/Basket\/src\/Model\/Exception\/UnknownProduct.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Exception; use App\\Basket\\Model\\ERP\\ProductId; final class UnknownProduct extends \\InvalidArgumentException { public static function withProductId(ProductId $productId): self { return new self(sprintf( 'Product with %s is unknown.', $productId-&gt;toString() )); } } The Basket aggregate should use the ERP system to request stock information before adding a product to the basket. The aggregate should reject the product if it is out of stock.Note: We keep the example simple. In a real world system this stock check would include many more variants, for example permanent or temporarily out of stock products, checkout even if a product is out of stock, and so on.But how do we get the ERP adapter into the aggregate? The answer is Method Injection. The Basket::addProduct defines the ERP system as a dependency for that method, and the caller of the method is responsible for providing an implementation. We will see that in action when we look at command handlers. For now, we align the method and update our test case.File: .\/Basket\/src\/Model\/Basket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model; \/\/... use App\\Basket\\Model\\ERP\\ERP; use App\\Basket\\Model\\Exception\\ProductOutOfStock; final class Basket extends AggregateRoot { \/\/... public function addProduct(ProductId $productId, ERP $ERP): void { if(array_key_exists($productId-&gt;toString(), $this-&gt;products)) { throw ProductAddedTwice::toBasket($this-&gt;basketId, $productId); } \/\/If the ERP system does not know the product an exception will be thrown here \/\/which will stop the operation. The aggregate can not deal with that situation \/\/as this is one of these \"this should never happen\" situations \/\/If we want an unbreakable domain model we would need to talk to the business \/\/and work out a failover plan triggered by a UnknownProductAddedToBasket event. $productStock = $ERP-&gt;getProductStock($productId); if(!$productStock) { $this-&gt;recordThat(ProductAddedToBasket::occur($this-&gt;basketId-&gt;toString(), [ 'product_id' =&gt; $productId-&gt;toString(), \/\/If we did not get a response, we add the product and check stock later again \/\/the shopping session should not be blocked by a temporarily unavailable ERP system 'stock_version' =&gt; null, 'stock_quantity'=&gt; null, 'quantity' =&gt; 1, ])); return; } if($productStock-&gt;quantity() === 0) { throw ProductOutOfStock::withProductId($productId); } $this-&gt;recordThat(ProductAddedToBasket::occur($this-&gt;basketId-&gt;toString(), [ 'product_id' =&gt; $productId-&gt;toString(), 'stock_version' =&gt; $productStock-&gt;version(), 'stock_quantity' =&gt; $productStock-&gt;quantity(), 'quantity' =&gt; 1, ])); } \/** * Apply given event *\/ protected function apply(AggregateChanged $event): void { switch ($event-&gt;messageName()) { case ShoppingSessionStarted::class: \/\/... case ProductAddedToBasket::class: \/** @var $event ProductAddedToBasket *\/ \/\/Use ProductId as index to avoid adding a product twice $this-&gt;products[$event-&gt;productId()-&gt;toString()] = [ 'stock_quantity' =&gt; $event-&gt;stockQuantity(), 'stock_version' =&gt; $event-&gt;stockVersion(), 'quantity' =&gt; $event-&gt;quantity() ]; break; } } } Basket::addProduct() has quite a bit of logic now and uses an external ERP system to request stock information of the product. In case the ERP system is temporarily unavailable the Basket aggregate accepts the product without a stock quantity check. Later in the checkout process we need to take care of this situation and check stock again. If we have a quantity stock conflict during checkout the order is routed to a support team who needs to contact the customer and offer an alternative.If we got stock information from the ERP system we check quantity and throw a ProductOutOfStock exception if it is zero.File: .\/Basket\/src\/Model\/Exception\/ProductOutOfStock.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Exception; use App\\Basket\\Model\\ERP\\ProductId; final class ProductOutOfStock extends \\RuntimeException { public static function withProductId(ProductId $productId): self { return new self(sprintf( 'Product with %s is out of stock.', $productId-&gt;toString() )); } } If everything is ok the Basket aggregate accepts the product and records the ProductAddedToBasket event but now with additional information, so we need to add new getter methods to the event.File: .\/Baset\/src\/Model\/Event\/ProductAddedToBasket.php&lt;?php declare(strict_types=1); namespace App\\Basket\\Model\\Event; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\ERP\\ProductId; use Prooph\\EventSourcing\\AggregateChanged; final class ProductAddedToBasket extends AggregateChanged { public function basketId(): BasketId { return BasketId::fromString($this-&gt;aggregateId()); } public function productId(): ProductId { return ProductId::fromString($this-&gt;payload()['product_id']); } public function stockQuantity(): ?int { return $this-&gt;payload()['stock_quantity']; } public function stockVersion(): ?int { return $this-&gt;payload()['stock_version']; } public function quantity(): int { return $this-&gt;payload()['quantity']; } } In the apply method of the Basket aggregate this additional information is added to the internal state so that we have access to it later.Testing the expanded version of Basket::addProduct() is still relatively simple but we end up with a lot more test methods to cover the different results of the method call. Check the additions below to see how we can use PHPUnit's prophecy integration to mock the ERP system and simulate different situations.File: .\/Basket\/tests\/Model\/BasketTest.php&lt;?php declare(strict_types=1); namespace App\\BasketTest\\Model; use App\\Basket\\Model\\Basket; use App\\Basket\\Model\\ERP\\ERP; use App\\Basket\\Model\\ERP\\ProductId; use App\\Basket\\Model\\ERP\\ProductStock; use App\\Basket\\Model\\Event\\ProductAddedToBasket; use App\\Basket\\Model\\Event\\ShoppingSessionStarted; use App\\Basket\\Model\\Basket\\BasketId; use App\\Basket\\Model\\Basket\\ShoppingSession; use App\\Basket\\Model\\Exception\\UnknownProduct; use App\\BasketTest\\TestCase; use Prooph\\EventSourcing\\AggregateChanged; use Prophecy\\Argument; use Ramsey\\Uuid\\Uuid; class BasketTest extends TestCase { \/** * @var ShoppingSession *\/ private $shoppingSession; \/** * @var BasketId *\/ private $basketId; \/** * @var ProductId *\/ private $product1; protected function setUp() { $this-&gt;shoppingSession = ShoppingSession::fromString('123'); $this-&gt;basketId = BasketId::fromString(Uuid::uuid4()-&gt;toString()); $this-&gt;product1 = ProductId::fromString('A1'); } \/** * @test *\/ public function it_starts_a_shopping_session() { $basket = Basket::startShoppingSession($this-&gt;shoppingSession, $this-&gt;basketId); \/** @var AggregateChanged[] $events *\/ $events = $this-&gt;popRecordedEvents($basket); $this-&gt;assertCount(1, $events); \/** @var ShoppingSessionStarted $event *\/ $event = $events[0]; $this-&gt;assertSame(ShoppingSessionStarted::class, $event-&gt;messageName()); $this-&gt;assertTrue($this-&gt;basketId-&gt;equals($event-&gt;basketId())); $this-&gt;assertTrue($this-&gt;shoppingSession-&gt;equals($event-&gt;shoppingSession())); } \/** * @test *\/ public function it_adds_a_product_if_stock_quantity_is_greater_than_zero() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted() ); $basket-&gt;addProduct($this-&gt;product1, $this-&gt;product1ERP()); \/** @var AggregateChanged[] $events *\/ $events = $this-&gt;popRecordedEvents($basket); $this-&gt;assertCount(1, $events); \/** @var ProductAddedToBasket $event *\/ $event = $events[0]; $this-&gt;assertSame(ProductAddedToBasket::class, $event-&gt;messageName()); $this-&gt;assertTrue($this-&gt;basketId-&gt;equals($event-&gt;basketId())); $this-&gt;assertTrue($this-&gt;product1-&gt;equals($event-&gt;productId())); $this-&gt;assertSame(5, $event-&gt;payload()['stock_quantity']); $this-&gt;assertSame(1, $event-&gt;payload()['stock_version']); $this-&gt;assertSame(1, $event-&gt;payload()['quantity']); } \/** * @test * @expectedException \\App\\Basket\\Model\\Exception\\ProductAddedTwice *\/ public function it_throws_exception_if_product_is_added_twice() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted(), $this-&gt;product1Added() ); \/\/Add same product again $basket-&gt;addProduct($this-&gt;product1, $this-&gt;product1ERP()); } \/** * @test * @expectedException \\App\\Basket\\Model\\Exception\\UnknownProduct *\/ public function it_stops_operation_if_product_is_unknown() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted() ); $ERP = $this-&gt;prophesize(ERP::class); \/\/This ERP mock knows no product $ERP-&gt;getProductStock($this-&gt;product1)-&gt;willThrow(UnknownProduct::withProductId($this-&gt;product1)); $basket-&gt;addProduct($this-&gt;product1, $ERP-&gt;reveal()); } \/** * @test *\/ public function it_adds_product_without_stock_info_if_ERP_is_unavailable() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted() ); $ERP = $this-&gt;prophesize(ERP::class); \/\/This ERP is unavailable $ERP-&gt;getProductStock($this-&gt;product1)-&gt;willReturn(null); $basket-&gt;addProduct($this-&gt;product1, $ERP-&gt;reveal()); \/** @var AggregateChanged[] $events *\/ $events = $this-&gt;popRecordedEvents($basket); $this-&gt;assertCount(1, $events); \/** @var ProductAddedToBasket $event *\/ $event = $events[0]; $this-&gt;assertSame(ProductAddedToBasket::class, $event-&gt;messageName()); $this-&gt;assertTrue($this-&gt;basketId-&gt;equals($event-&gt;basketId())); $this-&gt;assertTrue($this-&gt;product1-&gt;equals($event-&gt;productId())); $this-&gt;assertSame(1, $event-&gt;payload()['quantity']); \/\/No stock info present $this-&gt;assertSame(null, $event-&gt;payload()['stock_quantity']); $this-&gt;assertSame(null, $event-&gt;payload()['stock_version']); } \/** * @test * @expectedException \\App\\Basket\\Model\\Exception\\ProductOutOfStock *\/ public function it_does_not_add_product_if_product_is_out_of_stock() { $basket = $this-&gt;reconstituteBasketFromHistory( $this-&gt;shoppingSessionStarted() ); \/\/Set stock quantity to zero in the ERP mock $basket-&gt;addProduct($this-&gt;product1, $this-&gt;product1ERP(0)); } \/** * Helper method to reconstitute a Basket from history * * With this helper we get better type hinting in the test methods * because type hint for reconstituteAggregateFromHistory() is only AggregateRoot * * @param AggregateChanged[] ...$events * @return Basket *\/ private function reconstituteBasketFromHistory(AggregateChanged ...$events): Basket { return $this-&gt;reconstituteAggregateFromHistory( Basket::class, $events ); } \/** * Test helper to create a ShoppingSessionStarted event * * If we need to change signature of the event later, we have a central place in the test case * where we can align the creation. * * @return ShoppingSessionStarted *\/ private function shoppingSessionStarted(): ShoppingSessionStarted { return ShoppingSessionStarted::occur($this-&gt;basketId-&gt;toString(), [ 'shopping_session' =&gt; $this-&gt;shoppingSession-&gt;toString() ]); } \/** * Test helper to create a ProductAddedToBasket event * * If we need to change signature of the event later, we have a central place in the test case * where we can align the creation. * * @return ProductAddedToBasket *\/ private function product1Added(): ProductAddedToBasket { return ProductAddedToBasket::occur($this-&gt;basketId-&gt;toString(), [ 'product_id' =&gt; $this-&gt;product1-&gt;toString(), 'stock_quantity' =&gt; 5, 'stock_version' =&gt; 1, 'quantity' =&gt; 1, ]); } private function product1ERP(int $stockQuantity = 5): ERP { \/\/Create a Mock of the ERP interface $ERP = $this-&gt;prophesize(ERP::class); $ERP-&gt;getProductStock($this-&gt;product1)-&gt;willReturn(ProductStock::fromArray( [ 'product_id' =&gt; $this-&gt;product1-&gt;toString(), 'quantity' =&gt; $stockQuantity, 'version' =&gt; 1 ] )); return $ERP-&gt;reveal(); } } $ php vendor\/bin\/phpunit PHPUnit 6.3.1 by Sebastian Bergmann and contributors. ...... 6 \/ 6 (100%) Time: 27 ms, Memory: 4.00MB OK (6 tests, 21 assertions) "},{"id":"\/tutorial\/aggregate_dependencies.html#1-5-2","title":"Be Careful","content":"You need to be careful when using dependency injection in an aggregate method. In the example shown above, we only read data from an external system, and we can handle the cases when communication goes wrong, be it that the product could not be found or the external system is unavailable.Things get more complex when you want to write data to an external system. Let's say we want to update stock quantity for a product instead of requesting it. Such write operations should not be performed by the aggregate itself but instead by a process manager or a saga. In the next two chapters we're going to learn more about process managers and sagas and the difference between the two."},{"id":"\/tutorial\/aggregate_dependencies.html#1-5-3","title":"Links","content":" PHP DDD Cargo Sample\u00c2\u00b9 Hexagonal Architecture\u00c2\u00b2 "},{"id":"\/tutorial\/process_managers.html#1-6","title":"Process Managers","content":"This tutorial part is not ready yet.If you would like to see it online soon, you have some options that can significantly speed up writing: Add your github stars on the prooph repos Tell the world on twitter what you think about #prooph components Join our Gitter chat and give feedback "},{"id":"\/service-bus\/overview.html#2-1","title":"PSB Overview","content":"prooph\/service-bus acts as a messaging facade. It operates on the application layer and shields your domain model. In addition we also provide so-called \"message producers\" which connect prooph\/service-bus with messaging infrastructure on the system and network level."},{"id":"\/service-bus\/overview.html#2-1-1","title":"Installation","content":"composer require prooph\/service-bus "},{"id":"\/service-bus\/overview.html#2-1-2","title":"Quick Start","content":"&lt;?php use Prooph\\ServiceBus\\CommandBus; use Prooph\\ServiceBus\\Example\\Command\\EchoText; use Prooph\\ServiceBus\\Plugin\\Router\\CommandRouter; $commandBus = new CommandBus(); $router = new CommandRouter(); \/\/Register a callback as CommandHandler for the EchoText command $router-&gt;route('Prooph\\ServiceBus\\Example\\Command\\EchoText') -&gt;to(function (EchoText $aCommand): void { echo $aCommand-&gt;getText(); }); \/\/Expand command bus with the router plugin $router-&gt;attachToMessageBus($commandBus); \/\/We create a new Command $echoText = new EchoText('It works'); \/\/... and dispatch it $commandBus-&gt;dispatch($echoText); \/\/Output should be: It works "},{"id":"\/service-bus\/overview.html#2-1-3","title":"Live Coding Introduction","content":""},{"id":"\/service-bus\/overview.html#2-1-4","title":"Messaging API","content":"prooph\/service-bus allows you to define the API of your model with the help of messages. Command messages describe actions your model can handle. Event messages describe things that happened while your model handled a command. Query messages describe available information that can be fetched from your (read) model. Three different message bus implementations are available, too."},{"id":"\/service-bus\/overview.html#2-1-5","title":"CommandBus","content":"The CommandBus is designed to dispatch a message to exactly one handler or message producer. It does not return a result. Sending a command means fire and forget and enforces the Tell-Don't-Ask principle."},{"id":"\/service-bus\/overview.html#2-1-6","title":"EventBus","content":"The EventBus is able to dispatch a message to n listeners. Each listener can be a message handler or message producer. Like commands the EventBus doesn't return anything."},{"id":"\/service-bus\/overview.html#2-1-7","title":"QueryBus","content":"The QueryBus also dispatches a message to exactly one finder (special query message handler) but it returns a React\\Promise\\Promise. The QueryBus hands the query message to a finder along with a React\\Promise\\Deferred which needs to be resolved by the finder. We use promises to allow finders to handle queries asynchronous, for example using curl_multi_exec."},{"id":"\/service-bus\/overview.html#2-1-8","title":"Message Objects","content":"You are free to use your own message objects (or even primitive types if you want). All message buses are smart enough to handle them. If you need custom logic to handle your messages check out the list of available message bus plugins or write your own bus plugin. It is pretty straight forward."},{"id":"\/service-bus\/overview.html#2-1","title":"Synchronous Versus Asynchronous Processing","content":"PSB provides both possibilities behind a unified interface. Remember the statement \"Messaging means fire and forget\". The callee never knows if the message is processed synchronously or asynchronously. A message can be directly routed to its handler. In this case, we talk about synchronous message processing. If the message is routed to message producer it is normally processed asynchronously."},{"id":"\/service-bus\/message_bus.html#2-2-1","title":"Commanding","content":"When you want to apply CQRS the command bus is your best friend. It takes an incoming command message and routes it to the responsible command handler. The advantage of using a CommandBus instead of calling command handlers directly is that you can change your model without affecting the application logic. You can work with command versions to dispatch a newer version to a new command handler and older versions to old command handlers. Your model can support different versions at the same time which makes migrations a lot easier. Another feature of a command bus could be automatic transaction handling. And for distributed systems it is also interesting to push the command on a queue and handle it asynchronously."},{"id":"\/service-bus\/message_bus.html#2-2-2","title":"Eventing","content":"When dividing your domain logic into modules or bounded contexts you need a way to inform the outside world about events that happened in your model. An EventBus is responsible for dispatching event messages to all interested listeners. If a listener is part of another system the event may need to be sent to a remote interface."},{"id":"\/service-bus\/message_bus.html#2-2-3","title":"Querying","content":"A system based on Microservices requires a lightweight communication channel. The two most used protocols are HTTP request-response with resource API's and lightweight messaging. The latter is supported by prooph\/service-bus out-of-the-box but HTTP API's can be integrated too. The QueryBus is responsible for routing a query message to a so-called finder. The query indicates that the producer expects a response. The finder's responsibility is to fetch data from a data source using the query parameters defined in the query message. It is up to the finder if the data is fetched synchronous or asynchronous, so the QueryBus returns a React\\Promise\\Promise to the callee."},{"id":"\/service-bus\/message_bus.html#2-2-4","title":"API","content":"All three bus types extend the same base class Prooph\\ServiceBus\\MessageBus and therefore make use of an event-driven message dispatch process. Take a look at the CommandBus API. It is the same for EventBus and QueryBus except that the QueryBus returns a promise from QueryBus::dispatch.class CommandBus extends MessageBus { public function attach(string $eventName, callable $listener, int $priority = 0): ListenerHandler public function detach(ListenerHandler $handler): void \/** * @param mixed $command * * @throws CommandDispatchException *\/ public function dispatch($command): void; } The public API of a message bus is very simple. You can attach and detach plugins which are simple event listener aggregates and you can dispatch a message."},{"id":"\/service-bus\/message_bus.html#2-2-5","title":"Event-Driven Dispatch","content":"Internally a prooph message bus uses an event-driven process to dispatch messages. This offers a lot of flexibility without the need to define interfaces for messages. A message can be anything, even a string. prooph\/service-bus doesn't care. But using some defaults will reduce the number of required plugins and increase performance.But first let's take a look at the internals of a message dispatch process and the differences between the bus types."},{"id":"\/service-bus\/message_bus.html#2-2-5-1","title":"dispatch","content":"This action event is triggered right after MessageBus::dispatch($message) is invoked.The following default priorities are integrated:public const PRIORITY_INITIALIZE = 400000; public const PRIORITY_DETECT_MESSAGE_NAME = 300000; public const PRIORITY_ROUTE = 200000; public const PRIORITY_LOCATE_HANDLER = 100000; public const PRIORITY_INVOKE_HANDLER = 0; "},{"id":"\/service-bus\/message_bus.html#2-2-5-1-1","title":"initialize","content":"At this time the action event only contains the message. You can attach any listeners for initialization."},{"id":"\/service-bus\/message_bus.html#2-2-5-1-2","title":"detect-message-name","content":"Before a message handler can be located, the message bus needs to know how the message is named. Their are two possibilities to provide the information. The message can implement the Prooph\\Common\\Messaging\\HasMessageName interface. In this case the message bus picks the name directly from the message and sets it as the param message-name in the action event for use later. The detect-message-name event is not triggered. If the message does not implement the interface the detect-message-name priority can be used to add a plugin to inject the name using ActionEvent::setParam('message-name', $messageName). If no message-name was set by a listener, the message bus uses a fallback: FQCN of message in case of object message =&gt; message-name in case of string gettype($message) in all other cases "},{"id":"\/service-bus\/message_bus.html#2-2-5-1-3","title":"route","content":"During the route phase a plugin (typically a router) should provide the responsible message handler either in the form of a ready to use callable, an object or just a string. The latter should be a service id that can be passed to a service locator to get an instance of the message handler. The message handler should be set as action event param message-handler (for CommandBus and QueryBus) or event-listeners (for EventBus).As you can see, the command and query bus work with a single message handler whereas the event bus works with multiple listeners. This is one of the most important differences. Only the event bus allows multiple message handlers per message and therefore uses a slightly different dispatch process."},{"id":"\/service-bus\/message_bus.html#2-2-5-1-4","title":"locate-handler","content":"After routing the message, the message bus checks if the handler was provided as a string. This is the last chance to provide an object or callable as message handler. If no plugin was able to provide one the message bus throws an exception."},{"id":"\/service-bus\/message_bus.html#2-2-5-1-5","title":"invoke-handler","content":"With the message handler in place, it's time to invoke it with the message. callable message handlers are invoked by the bus. However, the invoke-handler \/ invoke-finder events are always triggered. At this stage all three bus types behave a bit different. CommandBus: invokes the handler with the command message. A invoke-handler event is triggered. QueryBus: much the same as the command bus but the message handler is invoked with the query message and a React\\Promise\\Deferred that needs to be resolved by the message handler aka finder. The query bus triggers a invoke-finder action event to indicate that a finder should be invoked and not a normal message handler. EventBus: loops over all event-listeners and triggers the locate-handler and invoke-handler action events for each message listener. Note: The command and query bus have a mechanism to check if the command or query was handled. If not they throw an exception. The event bus does not have such a mechanism as having no listener for an event is a valid case."},{"id":"\/service-bus\/message_bus.html#2-2-5-2","title":"finalize","content":"This action event is always triggered at the end of the process no matter if the process was successful or an exception was thrown. It is the ideal place to attach a monitoring plugin.If at any time a plugin or the message bus itself throws an exception it is caught and passed as param exception to this action event. The normal action event chain breaks and a finalize event is triggered instead. Plugins can then access the exception by getting it from the action event. A finalize plugin can unset the exception by calling ActionEvent::setParam(\"exception\", null). When all plugins are informed about the error and no one has unset the exception the message bus throws a Prooph\\ServiceBus\\Exception\\MessageDispatchException to inform the outside world about the error.Note: The query bus has another additional priority PRIORITY_PROMISE_REJECT which is used to reject the promise in case of an exception during the finalize event. If you want to remove the exception with a listener, you need to add your listener with a higher priority than that."},{"id":"\/service-bus\/message_bus.html#2-2-6-1","title":"Events &amp; Priorities","content":"There are two things to consider when upgrading from v5. The handle-error event is gone. If you want to have a plugin that tracks exceptions, you need to use the finalize event and check for the existence of an exception. This can look like this: $commandBus-&gt;attach( CommandBus::EVENT_FINALIZE, function (ActionEvent $actionEvent) { if ($ex = $actionEvent-&gt;getParam(CommandBus::EVENT_PARAM_EXCEPTION) { \/\/ do something } } ); The event bus has a listener exception collection mode. This means that you can activate the mode and the event bus will invoke all event listeners, catch possible exceptions and push them to an exception collection. If an exception is caught the event bus will throw an Prooph\\ServiceBus\\Exception\\EventListenerException at the end which contains all caught listener exceptions.To enable the collection mode you can attach the plugin Prooph\\ServiceBus\\Plugin\\ListenerExceptionCollectionMode. Detach the plugin to deactivate the mode again. There is a new dispatch event replacing all other previously existing events. It is controlled by event priorities instead. So if your previous plugin looked like this: $commandBus-&gt;attach( CommandBus::EVENT_INVOKE_HANDLER, function (ActionEvent $actionEvent) { if ($ex = $actionEvent-&gt;getParam(CommandBus::EVENT_PARAM_EXCEPTION) { \/\/ do something } } ); it now has to look like this:$commandBus-&gt;attach( CommandBus::EVENT_DISPATCH, function (ActionEvent $actionEvent) { if ($ex = $actionEvent-&gt;getParam(CommandBus::EVENT_PARAM_EXCEPTION) { \/\/ do something } }, CommandBus::PRIORITY_INVOKE_HANDLER );  Attaching to ActionEvents Instead of calling:$commandBus -&gt;getActionEventEmitter() -&gt;attachListener(string $event, callable $listener, int $priority = 1): ListenerHandler; It's more simple now:$commandBus-&gt;attach(string $event, callable $listener, int $priority = 1): ListenerHandler;  Plugins Instead of implementing Prooph\\Common\\Event\\ActionEventListenerAggregate a plugin now has to implement Prooph\\ServiceBus\\Plugin\\Plugin. The signature is:public function attachToMessageBus(MessageBus $messageBus): void; public function detachFromMessageBus(MessageBus $messageBus): void; "},{"id":"\/service-bus\/message_bus.html#2-2-6-2-1","title":"FinderInvokeStrategy","content":"Instead of having this:$finder-&gt;findQueryOne(QueryOne $query, Deferred $deferred = null): void; you simply have this:$finder-&gt;find(QueryOne $query, Deferred $deferred = null): void; If you want to go back to the old behaviour, you can do the following things:a)class MyFinder { public function find(Query $query, Deferred $deferred = null): void { if ($query instanceof QueryOne) { $this-&gt;findQueryOne($query, $deferred); } elseif ($query instanceof QueryTwo) { $this-&gt;findQueryTwo($query, $deferred); } else { throw new \\InvalidArgumentException('Unknown query passed'); } } } or b) Write a custom FinderInvokeStrategy."},{"id":"\/service-bus\/message_bus.html#2-2-6-2-2","title":"HandleCommandStrategy","content":"Same as for FinderInvokeStrategy, the handler is only expected have a handle(Command $command): void method. If you need the old behaviour back, implement this in your handlers or write a custom plugin."},{"id":"\/service-bus\/message_bus.html#2-2-6-2-3","title":"OnEventStrategy","content":"Same as above: There handler is only expected to have a onEvent(Event $message): void method."},{"id":"\/service-bus\/plugins.html#2-3","title":"PSB Plugins","content":"Plugins extend a message bus with additional functionality. PSB ships with a list of useful plugins that can be mixed and matched with your own implementations:"},{"id":"\/service-bus\/plugins.html#2-3-1-1","title":"Prooph\\ServiceBus\\Plugin\\Router\\CommandRouter","content":"Use the CommandRouter to provide a list of commands (identified by their names) and their responsible command handlers.\/\/You can provide the list as an associative array in the constructor ... $router = new CommandRouter(array('My.Command.BuyArticle' =&gt; new BuyArticleHandler())); \/\/... or using the programmatic api $router-&gt;route('My.Command.RegisterUser')-&gt;to(new RegisterUserHandler()); \/\/Command handlers can be objects like shown above or anything that is callable (callbacks, callable arrays, etc.) ... $router-&gt;route('My.Command.SendPaymentEmail')-&gt;to(array($mailer, \"handleSendPaymentEmail\")); \/\/... or a string that can be used by a DIC to locate the command handler instance $router-&gt;route('My.Command.PayOrder')-&gt;to(\"payment_processor\"); \/\/Add the router to a CommandBus $router-&gt;attachToMessageBus($commandBus); "},{"id":"\/service-bus\/plugins.html#2-3-1-2","title":"Prooph\\ServiceBus\\Plugin\\Router\\QueryRouter","content":"Use the QueryRouter to provide a list of queries (identified by their names) and their responsible finders.The QueryRouter shares the same base class with the CommandRouter so its interface looks exactly the same."},{"id":"\/service-bus\/plugins.html#2-3-1-3","title":"Prooph\\ServiceBus\\Plugin\\Router\\EventRouter","content":"Use the EventRouter to provide a list of event messages (identified by their names) and all interested listeners per event message.\/\/You can provide the list as an associative array in the constructor ... $router = new EventRouter(array('My.Event.ArticleWasBought' =&gt; array(new OrderCartUpdater(), new InventoryUpdater()))); \/\/... or using the programmatic api $router-&gt;route('My.Event.ArticleWasBought')-&gt;to(new OrderCartUpdater())-&gt;andTo(new InventoryUpdater()); \/\/Like command handlers, event message listeners can also be objects, callables or strings $router-&gt;route('My.Event.OrderWasPayed')-&gt;to(\"delivery_processor\"); \/\/Add the router to an EventBus $router-&gt;attachToMessageBus($eventBus); "},{"id":"\/service-bus\/plugins.html#2-3-1-4","title":"Prooph\\ServiceBus\\Plugin\\Router\\RegexRouter","content":"The RegexRouter works with regular expressions to determine handlers for messages. It can be used together with a CommandBus, a QueryBus or an EventBus but for the latter it behaves a bit different. When routing a command or query the RegexRouter makes sure that only one pattern matches. If more than one pattern matches it throws a Prooph\\ServiceBus\\Exception\\RuntimeException. On the other hand when routing an event each time a pattern matches the corresponding listener is added to the list of listeners.\/\/You can provide the pattern list as an associative array in the constructor ... $router = new RegexRouter(array('\/^My\\.Command\\.Buy.*\/' =&gt; new BuyArticleHandler())); \/\/... or using the programmatic api $router-&gt;route('\/^My\\.Command\\.Register.*\/')-&gt;to(new RegisterUserHandler()); \/\/Add the router to a CommandBus $router-&gt;attachToMessageBus($commandBus); \/\/When routing an event you can provide a list of listeners for each pattern ... $router = new RegexRouter(array('\/^My\\.Event\\.Article.*\/' =&gt; array(new OrderCartUpdater(), new InventoryUpdater()))); \/\/... or using the programmatic api $router-&gt;route('\/^My\\.Event\\.Article.*\/')-&gt;to(new OrderCartUpdater()); \/\/The RegexRouter does not provide a andTo method like the EventRouter. \/\/You need to call route again for the same pattern, \/\/otherwise the router throws an exception $router-&gt;route('\/^My\\.Event\\.Article.*\/')-&gt;to(new InventoryUpdater()); \/\/Add the router to an EventBus $router-&gt;attachToMessageBus($eventBus); "},{"id":"\/service-bus\/plugins.html#2-3-1-5","title":"Prooph\\ServiceBus\\Plugin\\Router\\AsyncSwitchMessageRouter","content":"The AsyncSwitchMessageRouter allows you to easily set up a single router to handle both your async and sync messages.To send messages via the Async Producer mark them with the Prooph\\ServiceBus\\Async\\AsyncMessage interface.The AsyncSwitchMessageRouter is a decorator that wraps your router. The first time the AsyncSwitchMessageRouter sees an async message it is sent via the Async Producer, after that the message is routed normally.\/\/You can define your primary router... $myRouter = new MyRouter(); \/\/ Create async message producer... $asyncMessageProducer = new AsyncMessageProducer(); \/\/ create your AsyncSwitchMessageRouter decorating your router... $router = new AsyncSwitchMessageRouter( $myRouter, $asyncMessageProducer ); \/\/Add the router to a CommandBus $router-&gt;attachToMessageBus($commandBus); "},{"id":"\/service-bus\/plugins.html#2-3-2","title":"Invoke Strategies","content":"An invoke strategy knows how a message handler can be invoked. You can register many invoke strategies at once depending on how many different handler types you are using. The best way is to choose a convention and go with it. PSB ships with the invoke strategies listed below."},{"id":"\/service-bus\/plugins.html#2-3-2-1","title":"Available Strategies","content":" HandleCommandStrategy: Prefixes the short class name of a command with handle. A command handler should have a public method named this way: AddProductHandler::handleAddProductToCart. If you prefer to have one command handler per command (recommended) then you don't need to attach the strategy but instead implement CommandHandler::__invoke. If you don't like __invoke you can also work with CommandHandler::handle. The HandleCommandStrategy checks if the handler has a single handle method if it cannot find an appropriate prefixed method name. OnEventStrategy: Prefixes the short class name of an event with on. A listener should have a public method named this way: OrderCartUpdater::onArticleWasBought. FinderInvokeStrategy: This strategy is responsible for invoking finders. It looks for a finder method named like the short class name of the query. Note: When a message bus detects that the message handler is callable invoke strategies are skipped and the message handler is directly invoked by the message bus."},{"id":"\/service-bus\/plugins.html#2-3-3","title":"Guards","content":"The service bus ships with a Prooph\\ServiceBus\\Plugin\\Guard\\RouteGuard and a Prooph\\ServiceBus\\Plugin\\Guard\\FinalizeGuard. You can use them to protect the command bus and the query bus. For the command bus the route guard is sufficient. If the Prooph\\ServiceBus\\Plugin\\Guard\\AuthorizationService does not allow access to the command, an Prooph\\ServiceBus\\Plugin\\Guard\\UnauthorizedException is thrown. The route guard passes the message to the Prooph\\ServiceBus\\Plugin\\Guard\\AuthorizationService as context, so you can make assertions on it.If you want to protect the query bus, you can also use the route guard, but in some situations, you want to deny access based on the result of the query. In this case it's important to make checks on the query results. The finalize guard passes a query result as context to the AuthorizationService.We also provide service-bus-zfc-rbac-bridge, a bridge to marry these guards with ZFC-Rbac. You can also find some configuration examples in this repository.Note: If you use both the route guard and the finalize guard on the query bus and you want to make assertions on the query result, you need to make sure that the AuthorizationService can distinguish between the contexts (route guard passes query, finalize guard passes result)If you want to use the RouteGuard or FinalizeGuard with an exposed message name in the exception message, configure your container accordingly, see: config\/services.php:21."},{"id":"\/service-bus\/plugins.html#2-3-4","title":"ServiceLocatorPlugin","content":"This plugin uses a Interop\\Container\\ContainerInterface implementation to lazy-load message handlers. The following example uses a ZF2 ServiceManager as a service locator and illustrates how it can be used together with a command bus:use Zend\\ServiceManager\\ServiceManager; \/\/We tell the ServiceManager that it should provide an instance of My\\Command\\DoSomethingHandler \/\/when we request it with the alias My.Command.DoSomethingHandler $serviceManager = new ServiceManager(new Config([ 'invokables' =&gt; [ 'My.Command.DoSomethingHandler' =&gt; 'My\\Command\\DoSomethingHandler' ] ])); \/\/The ZF2\\ServiceManager implements Interop\\Container\\ContainerInterface since v2.6 (new ServiceLocatorPlugin($serviceManager))-&gt;attachToMessageBus($commandBus); $router = new CommandRouter(); \/\/In the routing map we use the alias of the command handler $router-&gt;route('My.Command.DoSomething')-&gt;to('My.Command.DoSomethingHandler'); $router-&gt;attachToMessageBus($commandBus); With this technique you can configure the routing for all your messages without the need to create all message handlers on every request. Only the responsible message handlers are lazy loaded by the service locator plugin."},{"id":"\/service-bus\/plugins.html#2-3-5","title":"MessageProducerPlugin","content":"If you want to route all messages to a Prooph\\ServiceBus\\Async\\MessageProducer you can attach this plugin to a message bus. If it is attached to a command or query bus all messages will only be routed to the message producer. If it is attached to an event bus the message producer will be added to the list of event listeners.\/\/Let's say the zeromq message producer is available as a service in a container \/** @var \\Prooph\\ServiceBus\\Async\\MessageProducer $zeromqProducer *\/ $zeromqProducer = $container-&gt;get('async_event_producer'); \/\/We now only need to set up a message producer plugin and let the message bus use it. $messageProducerPlugin = new \\Prooph\\ServiceBus\\Plugin\\MessageProducerPlugin($zeromqProducer); $eventBus = new \\Prooph\\ServiceBus\\EventBus(); $messageProducerPlugin-&gt;attachToMessageBus($eventBus); \/\/Each event will now be routed to the async message producer $eventBus-&gt;dispatch($domainEvent); "},{"id":"\/service-bus\/async_message_producer.html#2-4","title":"Async Message Producer","content":"Messaging becomes really interesting if you process your messages asynchronously. PSB can hide such an asynchronous workflow behind a unified interface. You can start with synchronous message dispatching by routing your messages directly to message handlers and if you later want to improve response times you can switch to async processing on a per message basis by routing the appropriate messages to a message producer which hands them over to a messaging system like RabbitMQ, ZeroMQ, Gearman, Beanstalkd or any other queue."},{"id":"\/service-bus\/async_message_producer.html#2-4-1","title":"Available MessageProducer","content":" BernardProducer: Queue multi-backend providing different drivers like Doctrine DBAL and Predis (see https:\/\/github.com\/bernardphp\/bernard for a complete list of drivers) GuzzleHttpProducer: Send messages to a remote system using HTTP ZeroMQProducer: Async message handling using super fast and simple to set up ZeroMQ HumusAmqpProducer: Async handling using amqp protocol (f.e. with RabbitMQ). This also includes JSON-RPC features. EnqueueProducer: Async handling using Enqueue MQ library. "},{"id":"\/service-bus\/async_message_producer.html#2-4-2","title":"Usage","content":"If you want to set up a bus that handles all messages asynchronously you can do so by attaching a Prooph\\ServiceBus\\Plugin\\MessageProducerPlugin initialized with your message producer of choice to a message bus.Let's look at a simple example using the psb-zeromq-producer\/\/app bootstrap $container = new Container; $container['config'] = [ 'prooph' =&gt; [ 'zeromq_producer' =&gt; [ 'dsn' =&gt; 'tcp:\/\/127.0.0.1:5555', \/\/ ZMQ Server Address. 'persistent_id' =&gt; 'example', \/\/ ZMQ Persistent ID to keep connections alive between requests. 'rpc' =&gt; false, \/\/ Use as Query Bus. ] ] ]; $factory = \\Prooph\\ServiceBus\\Message\\ZeroMQ\\Container\\ZeroMQMessageProducerFactory; $zmqProducer = $factory($container); $commandBus = new \\Prooph\\ServiceBus\\CommandBus(); $messageProducerForwarder = new \\Prooph\\ServiceBus\\Plugin\\MessageProducerPlugin($zmqProducer); $messageProducerForwarder-&gt;attachToMessageBus($commandBus); $echoText = new ExampleCommand('It works'); $commandBus-&gt;dispatch($echoText); You can also route individual messages to message producers by using a message router plugin.Note: Prooph\\ServiceBus\\Plugin\\Router\\RegexRouter is a good choice if you want to handle all messages of a specific namespace async."},{"id":"\/service-bus\/async_message_producer.html#2-4-3","title":"Async Querying","content":"An async message producer for the QueryBus needs to provide a response by resolving the input React\\Promise\\Deferred. When using a messaging system like ZeroMQ for example you can make use of request\/response mode or RPC mode. HTTP APIs provide responses naturally. So these are both good candidates to use for remote querying."},{"id":"\/service-bus\/factories.html#2-5","title":"Interop + Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/service-bus ships with interop factories."},{"id":"\/service-bus\/factories.html#2-5-1","title":"Factory-Driven Message Bus Creation","content":"The concept behind these factories is simple but powerful. It allows us to provide you with bootstrapping logic for the message buses without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/service-bus\/factories.html#2-5-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the interop-container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide the requirements. You can always bootstrap a message bus by hand. Just look at the factories for inspiration in this case."},{"id":"\/service-bus\/factories.html#2-5-2","title":"Customizing via Configuration","content":"In the config folder of prooph\/service-bus you will find example configuration files. Configuration is a simple PHP array flavored with some comments to help you understand the structure.Now follow the simple steps below to integrate prooph\/service-bus in your framework and\/or application. Merge configuration into your application config either by hand or by using your framework's mechanism. Customize the configuration so that it meet your needs. The comments in the config file will tell you more. (Only required if not done by your framework) Make your application config available as a service in the Inversion of Control container. Use config as the service id (common id for application config). Register the message buses as services in your IoC container and use the factories located in src\/Container to create the different message buses. How you register a message bus depends on your container. Some containers like zend-servicemanager or pimple-interop allow you to map a service id to an invokable factory. If you use such an IoC container you are lucky. In this case you can use the prooph\/service-bus factories as-is. We recommend using Prooph\\ServiceBus\\&lt;CommandBus\/EventBus\/QueryBus&gt;::class as the service id. Note: If you're still unsure how to do it you might have a look at the BusFactoriesTest located in the tests folder."},{"id":"\/event-store\/intro.html#3-1","title":"Introduction","content":"Prooph Event Store is capable of persisting event messages that are organized in streams. Prooph\\EventStore\\EventStore itself is an interface with implementations available for different databases."},{"id":"\/event-store\/intro.html#3-1-1","title":"Quickstart","content":"&lt;?php declare(strict_types=1); namespace Prooph\\EventStore\\QuickStart; require_once __DIR__ . '\/..\/vendor\/autoload.php'; require_once __DIR__ . '\/..\/examples\/event\/QuickStartSucceeded.php'; use ArrayIterator; use Prooph\\Common\\Event\\ActionEvent; use Prooph\\Common\\Event\\ProophActionEventEmitter; use Prooph\\EventStore\\ActionEventEmitterEventStore; use Prooph\\EventStore\\InMemoryEventStore; use Prooph\\EventStore\\QuickStart\\Event\\QuickStartSucceeded; use Prooph\\EventStore\\Stream; use Prooph\\EventStore\\StreamName; use Prooph\\EventStore\\TransactionalActionEventEmitterEventStore; \/** * Here we use the InMemoryEventStore but in a real project * you need to chose another implementation. * * The InMemoryEventStore is good for testing purposes, though. * * Prooph\\Common\\Event\\ActionEventEmitter is an interface * that encapsulates functionality of an event dispatcher. * You can use the one provided by prooph\/common or * you write a wrapper for the event dispatcher used * by your web framework. *\/ $eventEmitter = new ProophActionEventEmitter(TransactionalActionEventEmitterEventStore::ALL_EVENTS); $eventStore = new ActionEventEmitterEventStore(new InMemoryEventStore(), $eventEmitter); \/** * We need a test event so let's create one. * * As a bare minimum events need to implement * Prooph\\Common\\Messaging\\Message. * * Note: It is possible to use your own events * in your domain and use a translator to * convert them. We'll come to that later. *\/ $quickStartSucceeded = QuickStartSucceeded::withSuccessMessage('It works'); \/** * Events are organized in so called event streams. * An event stream is a logical unit for a group of events. *\/ $streamName = new StreamName('event_stream'); $singleStream = new Stream($streamName, new ArrayIterator()); \/** * As we are using the InMemoryEventStore we have to create the event stream * each time running the quick start. With a real persistence adapter this * is not required. In this case you should create the stream once. For example * with the help of a migration script. * * Note: For more details see the docs of the adapter you want to use. *\/ $eventStore-&gt;create($singleStream); \/** * Next step would be to commit the transaction. * But let's attach a plugin first that prints some information about currently added events. * Plugins are simple event listeners. See the docs of prooph\/common for more details about event listeners. *\/ $eventStore-&gt;attach( ActionEventEmitterEventStore::EVENT_APPEND_TO, \/\/ InMemoryEventStore provides event hooks function (ActionEvent $actionEvent): void { \/** * In the *appendTo* action event a plugin has access to * all recorded events which were added in the current committed transaction. * It is the ideal place to attach a domain event dispatcher. * We only use a closure here to print the recorded events in the terminal *\/ $recordedEvents = $actionEvent-&gt;getParam('streamEvents'); foreach ($recordedEvents as $recordedEvent) { echo sprintf( \"Event with name %s was recorded. It occurred on %s \/\/\/\\n\\n\", $recordedEvent-&gt;messageName(), $recordedEvent-&gt;createdAt()-&gt;format('Y-m-d H:i:s') ); } }, -1000 \/\/ low priority, so after action happened ); \/** * Now we can easily add events to the stream ... *\/ $eventStore-&gt;appendTo($streamName, new ArrayIterator([$quickStartSucceeded \/*, ...*\/])); \/** * Once committed you can of course also load a set of events or the entire stream * Use $eventStore-&gt;loadEventsByMetadataFrom($streamName, $metadata, $minVersion); * to load a list of events * * or the $eventStore-&gt;load($streamName); to get all events *\/ $persistedEventStream = $eventStore-&gt;load($streamName); foreach ($persistedEventStream as $event) { if ($event instanceof QuickStartSucceeded) { echo $event-&gt;getText(); } } "},{"id":"\/event-store\/intro.html#3-1-2","title":"Video Introduction","content":""},{"id":"\/event-store\/implementations\/pdo_event_store\/intro.html#3-2-1-1","title":"Introduction","content":"The PDO Event Store is an implementation of prooph\/event-store that supports MySQL and MariaDB as well as PostgreSQL."},{"id":"\/event-store\/implementations\/pdo_event_store\/intro.html#3-2-1-1-1","title":"Video Introduction","content":""},{"id":"\/event-store\/implementations\/pdo_event_store\/intro.html#3-2-1-1-2","title":"Installation","content":"composer require prooph\/pdo-event-store "},{"id":"\/event-store\/implementations\/pdo_event_store\/intro.html#3-2-1-1-3","title":"Requirements","content":" PHP &gt;= 7.1 PDO_MySQL Extension or PDO_PGSQL Extension For MariaDB you need server vesion &gt;= 10.2.6. For MySQL you need server version &gt;= 5.7.9. For Postgres you need server version &gt;= 9.4."},{"id":"\/event-store\/implementations\/pdo_event_store\/intro.html#3-2-1-1-4","title":"Setup","content":"For MariaDB run the script in scripts\/mariadb\/01_event_streams_table.sql on your server.For MySQL run the script in scripts\/mysql\/01_event_streams_table.sql on your server.For Postgres run the script in scripts\/postgres\/01_event_streams_table.sql on your server.This will setup the required event streams table.If you want to use the projections, run additionally the scripts scripts\/mariadb\/02_projections_table.sql (for MariaDB), scripts\/mysql\/02_projections_table.sql (for MySQL) or scripts\/postgres\/02_projections_table.sql (for Postgres) on your server."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2","title":"Variants","content":"The PDO Event Store is an implementation of prooph\/event-store that supports MySQL and MariaDB as well as PostgreSQL.For a better understanding, we recommend to read the event-store docs, first."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-1","title":"Differences of MariaDb-\/MySql- &amp; PostgresEventStore","content":"The PostgresEventStore has a better performance (at least with default database configuration) and implements the TransactionalEventStore interface. If you need maximum performance or transaction support, we recommend to use the PostgresEventStore over the MariaDb-\/MySqlEventStore."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-2","title":"Event streams \/ projections table","content":"All known event streams are stored in an event stream table, so with a simple table lookup, you can find out what streams are available in your store.Same goes for the projections, all known projections are stored in a single table, so you can see what projections are available, and what their current state \/ stream positition \/ status is."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-3","title":"Load batch size","content":"When reading from an event streams with multiple aggregates (especially when using projections), you could end of with millions of events loaded in memory. Therefor the pdo-event-store will load events only in batches of 1000 by default. You can change to value to something higher to achieve even more performance with higher memory usage, or decrease it to reduce memory usage even more, with the drawback of having a not as good performance."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-4","title":"PDO Connection for event-store and projection manager","content":"It is important to use the same database for event-store and projection manager, you could use distinct pdo connections if you want to, but they should be both connected to the same database. Otherwise you will run into issues, because the projection manager needs to query the underlying database table of the event-store for its querying API.It's recommended to just use the same pdo connection instance for both."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-5","title":"Persistance Strategies","content":"This component ships with 9 default persistance strategies: MariaDbAggregateStreamStrategy MariaDbSimpleStreamStrategy MariaDbSingleStreamStrategy MySqlAggregateStreamStrategy MySqlSimpleStreamStrategy MySqlSingleStreamStrategy PostgresAggregateStreamStrategy PostgresSimpleStreamStrategy PostgresSingleStreamStrategy All persistance strategies have the following in common:The generated table name for a given stream is:'_' . sha1($streamName-&gt;toString()so a sha1 hash of the stream name, prefixed with an underscore is the used table name. You can query the event_streams table to get real stream name to stream name mapping.You can implement your own persistance strategy by implementing the Prooph\\EventStore\\Pdo\\PersistenceStrategy interface."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-5-1","title":"AggregateStreamStrategy","content":"This stream strategy should be used together with event-sourcing, if you use one stream per aggregate. For example, you have 2 instances of two different aggregates named user-123, user-234, todo-345 and todo-456, you would have 4 different event streams, one for each aggregate.This stream strategy is the most performant of all, but it will create a lot of database tables, which is something not everyone likes (especially DB admins).All needed database tables will be created automatically for you."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-5-2","title":"SingleStreamStrategy","content":"This stream strategy should be used together with event-sourcing, if you want to store all events of an aggregate type into a single stream, for example user-123 and user-234 should both be stored into a stream called user.You can also store all stream of all aggregate types into a single stream, for example your aggregates user-123, user-234, todo-345 and todo-456 can all be stored into a stream called event_stream.This stream strategy is slightly less performant then the aggregate stream strategy.You need to setup the database table yourself when using this strategy. An example script to do that can be found here."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-5-3","title":"SimpleStreamStrategy","content":"This stream strategy is not meant to be used for event-sourcing. It will create simple event streams without any constraints at all, so having two events of the same aggregate with the same version will not rise any error.This is very useful for projections, where you copy events from one stream to another (the resulting stream may need to use the simple stream strategy) or when you want to use the event-store outside the scope of event-sourcing.You need to setup the database table yourself when using this strategy. An example script to do that can be found here."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-5-4","title":"Using custom stream strategies","content":"When you query the event streams a lot, it might be a good idea to create your own stream strategy, so you can add custom indexes to your database tables. When using with the MetadataMatcher, take care that you add the metadata matches in the right order, so they can match your indexes."},{"id":"\/event-store\/implementations\/pdo_event_store\/variants.html#3-2-1-2-5-5","title":"Disable transaction handling","content":"You can configure the event store to disable transaction handling completely. In order to do this, set the last parameter in the constructor to true (or configure your interop config factory accordingly, key is disable_transaction_handling).Enabling this feature will disable all transaction handling and you have to take care yourself to start, commit and rollback transactions.Note: This could lead to problems using the event store, if you did not manage to handle the transaction handling accordingly. This is your problem and we will not provide any support for problems you encounter while doing so."},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-2","title":"MariaDbEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'persistence_strategy' =&gt; MariaDbSingleStreamStrategy::class, \/\/ service id for the used persistance strategy 'load_batch_size' =&gt; 1000, \/\/ how many events a query should return in one batch, defaults to 1000 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'message_factory' =&gt; FQCNMessageFactory::class, \/\/ message factory to use, defauls to `FQCNMessageFactory::class` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MariaDbEventStore' =&gt; [ \\Prooph\\EventStore\\Container\\MariaDbEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('MariaDbEventStore');"},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-3","title":"MariaDbProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'MariaDbEventStore', 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'projections_table' =&gt; 'projections', \/\/ projection table to use, defaults to `projections` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MariaDbProjectionManager' =&gt; [ \\Prooph\\EventStore\\Container\\MariaDbProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('MariaDbProjectionManager');"},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-4","title":"MySqlEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'persistence_strategy' =&gt; MySqlSingleStreamStrategy::class, \/\/ service id for the used persistance strategy 'load_batch_size' =&gt; 1000, \/\/ how many events a query should return in one batch, defaults to 1000 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'message_factory' =&gt; FQCNMessageFactory::class, \/\/ message factory to use, defauls to `FQCNMessageFactory::class` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MySqlEventStore' =&gt; [ \\Prooph\\EventStore\\Container\\MySqlEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('MySqlEventStore');"},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-5","title":"MySqlProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'MySqlEventStore', 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'projections_table' =&gt; 'projections', \/\/ projection table to use, defaults to `projections` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MySqlProjectionManager' =&gt; [ \\Prooph\\EventStore\\Container\\MySqlProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('MySqlProjectionManager');"},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-6","title":"PostgresEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'persistence_strategy' =&gt; PostgresSingleStreamStrategy::class, \/\/ service id for the used persistance strategy 'load_batch_size' =&gt; 1000, \/\/ how many events a query should return in one batch, defaults to 1000 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'message_factory' =&gt; FQCNMessageFactory::class, \/\/ message factory to use, defauls to `FQCNMessageFactory::class` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'PostgresEventStore' =&gt; [ \\Prooph\\EventStore\\Container\\PostgresEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('PostgresEventStore');"},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-7","title":"PostgresProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'PostgresEventStore', 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'projections_table' =&gt; 'projections', \/\/ projection table to use, defaults to `projections` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'PostgresProjectionManager' =&gt; [ \\Prooph\\EventStore\\Container\\PostgresProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('PostgresProjectionManager');"},{"id":"\/event-store\/implementations\/pdo_event_store\/interop_factories.html#3-2-1-3-1-8","title":"PdoConnectionFactory","content":"[ 'prooph' =&gt; [ 'pdo_connection' =&gt; [ 'default' =&gt; [ 'schema', \/\/ one of mysql or pgsql 'user', \/\/ username to use 'password', \/\/ password to use 'port', \/\/ port to use 'host' =&gt; '127.0.0.1', \/\/ host name, defaults to `127.0.0.1` 'dbname' =&gt; 'event_store', \/\/ database name, defaults to `event_store` 'charset' =&gt; 'utf8', \/\/ chartset, defaults to `UTF-8`, ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'my_pdo_connection' =&gt; [ \\Prooph\\EventStore\\Container\\PdoConnectionFactory::class, 'default', ], ], ], \/\/... other application config here ] $pdoConnection = $container-&gt;get('my_pdo_connection');"},{"id":"\/event-store\/event_store_plugins.html#3-3","title":"Plugins &amp; Extensions","content":"A prooph Event Store can be expanded using plugins. Some plugins are provided by prooph but you can write your own ones to customize the event store using event hooks."},{"id":"\/event-store\/event_store_plugins.html#3-3-1","title":"Event Hooks","content":"Requirements: an event store wrapped with Prooph\\EventStore\\ActionEventEmitterEventStore.Action events are triggered when methods of the event store are invoked. The action events are named like the event store methods. The following events are available (event target is always the event store): create: event params: stream - result params: streamExistsAlready appendTo: event params: streamName, streamEvents - result params: streamNotFound, concurrencyException load: event params: streamName, fromNumber, count, metadatamatcher - result params: streamEvents, streamNotFound loadReverse: event params: streamName, fromNumber, count, metadatamatcher - result params: streamEvents, streamNotFound delete: event params: streamName - result params: streamNotFound hasStream: event params: streamName - result params: result fetchStreamMetadata: event params: streamName - result params: metadata, streamNotFound updateStreamMetadata: event params: streamName, metadata - result params: streamNotFound fetchStreamNames: event params: filter, metadataMatcher, limit, offset - result params: streamNames fetchStreamNamesRegex: event params: filter, metadataMatcher, limit, offset - result params: streamNames fetchCategoryNames: event params: filter, offset, limit - result params: categoryNames fetchCategoryNamesRegex: event params: filter, offset, limit - result params: categoryNames If the event store implements \\Prooph\\EventStore\\TransactionalActionEventEmitterEventStore, the following additional events are available: beginTransaction: event params: none - result params: transactionAlreadyStarted commit: event params: none - result params: transactionNotStarted rollback: event params: none - result params: `transactionNotStarted "},{"id":"\/event-store\/event_store_plugins.html#3-3-2","title":"Attaching Plugins","content":"If you took a look at the quick start, you should already be familiar with the possibility to attach an event listener plugin.$eventStore-&gt;attach( 'commit', function (\\Prooph\\Common\\Event\\ActionEvent $actionEvent) { \/\/plugin logic here }, 1000 \/\/ priority ); More complex plugins are typically provided as classes with their own dependencies. A plugin can implement the Prooph\\EventStore\\Plugin\\Plugin interface and can then attach itself to the event store in the Plugin::attachToEventStore($eventStore) method. Implementing the interface is especially useful when you use the event store factory."},{"id":"\/event-store\/event_store_plugins.html#3-3-3","title":"Plugin Use Cases","content":"The event-driven system opens the door for customizations. Here are some ideas of what you can do with it: Attach a domain event dispatcher on the create and appendTo event Filter events before they are stored Add event metadata like a causation id (id of the command which caused the event) Convert events into custom event objects before they are passed back to a repository Implement your own Unit of Work and synchronize it with the transaction, commit and rollback events ... "},{"id":"\/event-store\/event_store_plugins.html#3-3-4","title":"Metadata enricher","content":"By default, the component is shipped with a plugin to automatically add metadata to each event. For instance, you may want to add information about the command which caused the event or even the user who triggered that command.Here is an example of its usage:&lt;?php use Prooph\\Common\\Messaging\\Message; use Prooph\\EventStore\\Metadata\\MetadataEnricher; use Prooph\\EventStore\\Metadata\\MetadataEnricherAggregate; use Prooph\\EventStore\\Metadata\\MetadataEnricherPlugin; class IssuerMetadataEnricher implements MetadataEnricher { \/\/ ... public function enrich(Message $event): Message { if ($this-&gt;currentUser) { $event = $event -&gt;withAddedMetadata('issuer_type', 'user') -&gt;withAddedMetadata('issuer_id', $this-&gt;currentUser-&gt;id()); } return $event; } } $plugin = new MetadataEnricherPlugin(new MetadataEnricherAggregate([ $issuerMetadataEnricher, $causationMetadataEnricher, $otherMetadataEnricher, ])); $plugin-&gt;attachToEventStore($eventStore); "},{"id":"\/event-store\/event_store_plugins.html#3-3-5","title":"Internal metadata","content":"All internal metadata is prefixed with _ (underscore), f.e. _causation_id. Do not use metadata keys starting with an underscore, as this is reserved for prooph internals."},{"id":"\/event-store\/event_store_plugins.html#3-3-6","title":"ReadOnlyEventStoreWrapper","content":"The event store interface is divided into read-only methods, see Prooph\\EventStore\\ReadOnlyEventStore and write methods see Prooph\\EventStore\\EventStore. This distinction is useful in situations where you want to enforce ready-only access to the event store.In case you need a read only event store, you can wrap your existing event store implementation with the ReadOnlyEventStoreWrapper.$readOnlyEventStore = new ReadOnlyEventStoreWrapper($eventStore); "},{"id":"\/event-store\/projections.html#3-4","title":"Projections","content":"New in v7 are queries and projectons."},{"id":"\/event-store\/projections.html#3-4-1","title":"Queries","content":"Here, we are discussing event store queries, not queries on your read model. An event store query reads one or multiple event streams, aggregates some state from it and makes it accessible. A query is a non-persistent function, that will only be executed once, and return a result. That's it.To get started, let's take a simple example where we want to query the event-store for how often a given user has changed his username.$query = $projectionManager-&gt;createQuery(); $query -&gt;init(function (): array { return ['count' =&gt; 0]; }) -&gt;fromStream('user-123') -&gt;when([ 'user-name-changed' =&gt; function ( array $state, UsernameChanged $event ): array { $state['count']++; return $state; } ]) -&gt;run(); echo 'user 123 changed his name ' . $query-&gt;getState()['count'] . ' times'; You can also reset and run the query again:$query-&gt;reset(); $query-&gt;run(); Or you can stop the query at any point in time.$query = $projectionManager-&gt;createQuery(); $query -&gt;init(function (): array { return ['count' =&gt; 0]; }) -&gt;fromStream('user-123') -&gt;when([ 'user-name-changed' =&gt; function ( array $state, UsernameChanged $event ): array { $state['count']++; $this-&gt;stop(); \/\/ stop query now return $state; } ]) -&gt;run(); Queries can be used to answer a given question easily because you don't need to figure out in which read model the data is present (maybe it's not?) and how to query it there (maybe a lot of joins are needed in RDBMS). Also you can do temporal queries very easily, which is hard to impossible to do with any other database system."},{"id":"\/event-store\/projections.html#3-4-2","title":"Projections","content":"Projections are like queries, but they are persistent, the created state is also persistent and can be queried later, and the projection runs forever (in most cases).Compared to queries, the projectors have a couple of additional methods:public function getName(): string; public function emit(Message $event): void; public function linkTo(string $streamName, Message $event): void; public function delete(bool $deleteEmittedEvents): void;  getName() - obviously returns the given name of that projection emit(Message $event) - emits a new event that will be persisted on a stream with the same name as the projection linkTo(string $streamName, Message $event) - emits a new event, that will be persisted on a specific stream delete(bool $deleteEmittedEvents) - deletes the projection completely, the $deleteEmittedEvents flag tells whether or not to delete emitted events. An example:$projector = $projectionManager-&gt;createProjection('test_projection'); $projector -&gt;fromStream('user-123') -&gt;whenAny( function (array $state, Message $event): array { $this-&gt;linkTo('foo', $event); \/\/ create a copy of the event to a new stream return $state; } ) -&gt;run(); $projector = $projectionManager-&gt;createProjection('test_projection'); $projector -&gt;init(function (): array { return ['count' =&gt; 0]; }) -&gt;fromCategory('user') -&gt;when([ 'user-registered' =&gt; function (array $state, Message $event): array { $state['count']++; return $state; } ) -&gt;run(); This would count all registered users."},{"id":"\/event-store\/projections.html#3-4-2-1","title":"Options","content":"There are three options common to all projectors:OPTION_CACHE_SIZE = 'cache_size';The cache size is how many stream names are cached in memory, the higher the number the less queries are executed and therefore the projection runs faster, but it consumes more memory.OPTION_SLEEP = 'sleep';The sleep options tells the projection to sleep that many microseconds before querying the event store again when no events were found in the last trip. This reduces the number of cpu cycles without the projection doing any real work.OPTION_PERSIST_BLOCK_SIZE = 'persist_block_size';The persist block size tells the projector to persist its changes after a given number of operations. This increases the speed of the projection a lot. When you only persist every 1000 events compared to persist on every event, then 999 write operations are saved. The higher the number, the fewer write operations are made to your system, making the projections run faster. On the other side, in case of an error, you need to redo the last operations again. If you are publishing events to the outside world within a projection, you may think of a persist block size of 1 only.OPTION_LOCK_TIMEOUT_MS = 'lock_timeout_ms'Indicates the time (in microseconds) the projector is locked. During this time no other projector with the same name can be started. A running projector will update the lock timeout on every loop.OPTION_PCNTL_DISPATCH = 'false'Enable dispatching of process signals to registered signal handlers while the projection is running. You must still register your own signal handler and act accordingly. For example to gracefully stop the projection you could do$projection = $projectionManager-&gt;createProjection( 'test_projection', [ Projector::OPTION_PCNTL_DISPATCH =&gt; true, ] ); pcntl_signal(SIGQUIT, function () use ($projection) { $projection-&gt;stop(); }); $projection-&gt;run(); "},{"id":"\/event-store\/projections.html#3-4-3","title":"Read Model Projections","content":"Projections can also be used to create read models. A read model has to implement Prooph\\EventStore\\Projection\\ReadModel. Prooph also ships with an Prooph\\EventStore\\Projection\\AbstractReadModel that helps you implement a read model yourself.One nice thing about read model projections is that you don't need a migration script for your read models. When you need to make a change to your read model, you simply alter your read model implementation, stop your current running projections, reset it, and run it again."},{"id":"\/event-store\/projections.html#3-4-3-1","title":"Options","content":"The read model projectors have the same options as the normal projectors. See above for more explanations."},{"id":"\/event-store\/projections.html#3-4-3-2","title":"Example","content":"$projector = $projectionManager-&gt;createReadModelProjection( 'test_projection', $readModel ); $projector -&gt;fromAll() -&gt;when([ 'user-created' =&gt; function ($state, Message $event) { $this-&gt;readModelProjection()-&gt;insert( 'name', $event-&gt;payload()['name'] ); }, 'username-changed' =&gt; function ($state, Message $event) { $this-&gt;readModelProjection()-&gt;update( 'name', $event-&gt;payload()['name'] ); } ]) -&gt;run(); "},{"id":"\/event-store\/projections.html#3-4-4","title":"Projection Manager","content":"The projection manager can do the following for you: Create queries &amp; projectors Delete \/ reset \/ stop projections Fetch projection names Fetch projection status Fetch projection stream position Fetch projection state While most methods are pretty straightforward, the delete \/ reset \/ stop projection methods may need some additional explanation:When you call stopProjection($name) (or delete or reset) a message is sent to the projection. This will notify the running projection that it should act accordingly. This means that once you call stopProjection, it could take a few seconds before the projection is finally stopped."},{"id":"\/event-store\/projections.html#3-4-5","title":"Internal projection names","content":"All internal projection names are prefixed with $ (dollar-sign), f.e. $ct-. Do not use projection names starting with a dollar-sign, as this is reserved for prooph internals."},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1","title":"Overview","content":"The standard projections are some kind of event-indexing, so you can retrieve events from all streams at once (AllStreamProjectionRunner), by category (CategoryStreamProjectionRunner) or by message name (MessageNameStreamProjectionRunner)."},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1-1","title":"Installation","content":"composer require prooph\/standard-projections "},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1-2","title":"Requirements","content":" PHP &gt;= 7.1 Prooph EventStore v7 "},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1-3","title":"AllStreamProjectionRunner","content":"Imagine you have two streams, a stream called user and a stream called blogposts. If you are interessted in all events coming from both streams, you can use an EventStoreQuery like this:$eventStore -&gt;createQuery() -&gt;fromAll() This is slightly unperformant, especially when you have one stream per aggregate, so that you have to query thousands of streams. This is where the AllStreamProjectionRunner comes handy. It projects all events from all streams into a single large stream, so you can run queries like:$eventStore -&gt;createQuery() -&gt;fromStream('$all') "},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1-4","title":"CategoryStreamProjectionRunner","content":"Let's say you use one stream per aggregate for users. So you have event streams with names: user-1, user-2 and so on. You are interested in the events from all user-streams, so your query looks like:$eventStore -&gt;createQuery() -&gt;fromCategory('user') With the CategoryStreamProjectionRunner you create a single stream for all those events. You can query it like:$eventStore -&gt;createQuery() -&gt;fromStream('$ct-user') "},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1-5","title":"MessageNameStreamProjectionRunner","content":"The MessageNameStreamProjectionRunner creates a stream for each occurring message name. Let's say you have user-streams with one stream per aggregate again, and streams like user-1, user-2, and so on. You are interessted in all UserWasRegistered events, so your query looks like:$eventStore -&gt;createQuery() -&gt;fromCategory('user') -&gt;when( [ UserWasRegistered::class =&gt; function (array $state, UserWasRegistered $event): void { \/\/ do something } ] ) This is unperformant in two ways: First we need to query all user-streams and then we need to iterate over events, we are not interested in. With the MessageNameStreamProjectionRunner your query would look like:$eventStore -&gt;createQuery() -&gt;fromStream('$mn-UserRegistered') "},{"id":"\/event-store\/standard_projections\/overview.html#3-5-1-6","title":"Usage","content":"The runners are expected to run in a simple CLI script. As it's framework agnostic, you have to provide these cli-scripts yourself. This is how they basically look like:&lt;?php $container = require 'container.php'; $projectionManager = $container-&gt;get(\\Prooph\\EventStore\\Projection\\ProjectionManager::class); $runner = new \\Prooph\\StandardProjections\\AllStreamProjectionRunner($projectionManager); $runner(); "},{"id":"\/event-store\/upcasting.html#3-6","title":"Upcasting","content":"Imagine v1 of your application already runs in production. You've worked on great new features the last weeks and want to deploy v1.1 but the structure of some domain events changed. The new versions of your aggregates would not be able to replay v1 domain events correctly. To solve the issue you can upcast your history events."},{"id":"\/event-store\/upcasting.html#3-6-1","title":"How does it work?","content":"Basically you need to write a migration script (much like a normal DB migration script). The script should load all effected events from the event store and manipulate them to be compliant with version 1.1 of your aggregates. Then simply replace the original events in the stream with the changed ones.Note: The event store offers methods to load events from a stream and add new ones, but it has no method to replace them. The reason for that is simple: \"Upcasting\" is something your normal program should not have access to. It is only a way to upgrade your application to the next version, so your upcasting script needs to make use of low-level functionality provided by the underlying driver for the event store adapter."},{"id":"\/event-store\/upcasting.html#3-6-2","title":"But how do I avoid conflicts during the upcasting process?","content":"Well, that depends on your infrastructure and deployment strategy. The easiest way is to take your application offline, perform the upcasting script, deploy the new version of the application, and bring the system online again.A more complex option with no or very little downtime is to use a special MessageFactory. First, make the MessageFactory aware of the differences between v1 and v1.1 of your events. Deploy the modified factory together with version 1.1 of your application. The factory takes care of translating old events into new ones. Perform the \"upcasting\" script in the background, and, once it has replaced all old events, you can remove the translation logic from the factory again and exchange it with the simple factory you used before.Note: Each event store adapter allows you to set it up with a custom message factory. Please refer to the adapter documentation of your choice to get more information."},{"id":"\/event-store\/upcasting.html#3-6-3","title":"Upasting on the fly","content":"Starting in v7 prooph offers an upcasting plugin for the event store. Setup is very easy:$upcaster = new MyUpcaster(); $plugin = new UpcastingPlugin($upcaster); $plugin-&gt;attachToEventStore($eventStore); So next time you load your events, they will get upcasted automatically (but not persisted back to the database).The upcaster interface is very simple:interface Upcaster { \/** * @param Message $message * @return array of messages *\/ public function upcast(Message $message): array; } Prooph also ships with a SingleEventUpcaster, an abstract class to help you create upcasters easily. Additionally an UpcasterChain is provided, so you can combine upcasters easily:$upcaster1 = new MyUpcaster1(); $upcaster2 = new MyUpcaster2(); $upcaster3 = new MyUpcaster3(); $chain = new UpcasterChain($upcaster1, $upcaster2, $upcaster3); $plugin = new UpcastingPlugin($chain); $plugin-&gt;attachToEventStore($eventStore); "},{"id":"\/event-store\/interop_factories.html#3-7","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-store\/interop_factories.html#3-7-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-store\/interop_factories.html#3-7-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-store\/interop_factories.html#3-7-1-2","title":"InMemoryEventStoreFactory","content":"If the requirements are met, you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instantiating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'inmemoryeventstore' =&gt; [ \\Prooph\\EventStore\\Container\\InMemoryEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('inmemoryeventstore');"},{"id":"\/event-store\/interop_factories.html#3-7-1-2-1","title":"ReadOnlyEventStoreWrapper","content":"If you want to have a read only event store, just add 'read_only' =&gt; true to your event store config."},{"id":"\/event-store\/interop_factories.html#3-7-1-3","title":"InMemoryProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'inmemoryeventstore', ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'inmemoryeventstoreprojectionmanager' =&gt; [ \\Prooph\\EventStore\\Container\\InMemoryProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('inmemoryeventstoreprojectionmanager');"},{"id":"\/event-store\/migration.html#3-8-1","title":"Moved classes","content":"The Prooph\\EventStore\\Snapshot\\* classes are now moved to their own repository, SnapshotStore.The Prooph\\EventStore\\Aggregate\\* classes are now moved into the event-sourcing repository."},{"id":"\/event-store\/migration.html#3-8-2","title":"Interfaces VS adapters","content":"The event store now ships with a Prooph\\EventStore\\ReadOnlyEventStore and a Prooph\\EventStore\\EventStore interface. No event store adapters exist anymore, instead there are different implementations of the event store."},{"id":"\/event-store\/migration.html#3-8-3","title":"ActionEventEmitterEventStore","content":"In order to use action events like in v6, you need to wrap your event store.$eventStore = new ActionEventEmitterEventStore($eventStore); or$eventStore = new TransactionalActionEventEmitterEventStore($eventStore); Also, there are no more .pre and .post commit hooks anymore, instead, this is handled with different priorities now."},{"id":"\/event-store\/migration.html#3-8-4","title":"Plugins","content":"Instead of calling$plugin-&gt;setUp($eventStore); you now need to call$plugin-&gt;attachToEventStore($eventStore); "},{"id":"\/event-store\/migration.html#3-8-5","title":"Interaction with the event store","content":"If you are using the event-store together with the event-sourcing component, most stuff is pretty much unchanged for you, as you don't interact with the event store directly (this is done by the event-sourcing component).If you are making calls to the event store yourself, take a look at the event_store docs on how the new usage is."},{"id":"\/event-store\/migration.html#3-8-6","title":"DB migrations","content":"If you are using v6 with MySQL (using doctrine adpater) and you want to switch to v7 with MySQL (using pdo-event-store), you need to upgrade your database before you do this (same for other db vendors of course). The way events are persisted has changed and you cannot simply update your source code to make this change. You need to write a migration script, take the database offline, perform the migration and go back online.Things to do to migrate: Read all events Update event metadata Persist the event back to a new stream created with v7 This would need to be done for all event streams.As this is a very tough job, we don't provide any migration script currently. For some applications, a downtime is not acceptable, in which case v7 might not be the right choice. You should use it when you can take the application offline for a while and perform the DB migration, or you can wait until you start a new project to use it.We will support v6 series with bugfixes until 3 Dec 2017."},{"id":"\/event-sourcing\/intro.html#4-1","title":"Introduction","content":"Simple and lightweight event sourcing library with out of the box support for prooph\/event-store"},{"id":"\/event-sourcing\/intro.html#4-1-1","title":"Installation","content":"composer require prooph\/event-sourcing "},{"id":"\/event-sourcing\/intro.html#4-1-2","title":"Quickstart","content":"&lt;?php declare(strict_types=1); namespace { require_once __DIR__ . '\/..\/vendor\/autoload.php'; } namespace My\\Model { use Assert\\Assertion; use Prooph\\EventSourcing\\AggregateChanged; use Prooph\\EventSourcing\\AggregateRoot; use Ramsey\\Uuid\\Uuid; class User extends AggregateRoot { \/** * @var Uuid *\/ private $uuid; \/** * @var string *\/ private $name; \/** * ARs should be created via static factory methods *\/ public static function nameNew(string $username): User { \/\/Perform assertions before raising a event Assertion::notEmpty($username); $uuid = Uuid::uuid4(); \/\/AggregateRoot::__construct is defined as protected so it can be called in a static factory of \/\/an extending class $instance = new self(); \/\/Use AggregateRoot::recordThat method to apply a new Event $instance-&gt;recordThat(UserWasCreated::occur($uuid-&gt;toString(), ['name' =&gt; $username])); return $instance; } public function userId(): Uuid { return $this-&gt;uuid; } public function name(): string { return $this-&gt;name; } public function changeName(string $newName): void { Assertion::notEmpty($newName); if ($newName !== $this-&gt;name) { $this-&gt;recordThat(UserWasRenamed::occur( $this-&gt;uuid-&gt;toString(), ['new_name' =&gt; $newName, 'old_name' =&gt; $this-&gt;name] )); } } \/** * Every AR needs a hidden method that returns the identifier of the AR as a string *\/ protected function aggregateId(): string { return $this-&gt;uuid-&gt;toString(); } protected function apply(AggregateChanged $event): void { switch (get_class($event)) { case UserWasCreated::class: \/\/Simply assign the event payload to the appropriate properties $this-&gt;uuid = Uuid::fromString($event-&gt;aggregateId()); $this-&gt;name = $event-&gt;username(); break; case UserWasRenamed::class: $this-&gt;name = $event-&gt;newName(); break; } } } \/** * ProophEventSourcing domain events are of the type AggregateChanged *\/ class UserWasCreated extends AggregateChanged { public function username(): string { return $this-&gt;payload['name']; } } \/** * ProophEventSourcing domain events are of the type AggregateChanged *\/ class UserWasRenamed extends AggregateChanged { public function newName(): string { return $this-&gt;payload['new_name']; } public function oldName(): string { return $this-&gt;payload['old_name']; } } \/** * Simple interface for a user repository *\/ interface UserRepository { public function save(User $user): void; public function get(Uuid $uuid): ?User; } } namespace My\\Infrastructure { use My\\Model\\User; use My\\Model\\UserRepository; use Prooph\\EventSourcing\\Aggregate\\AggregateRepository; use Prooph\\EventSourcing\\Aggregate\\AggregateType; use Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator; use Prooph\\EventStore\\EventStore; use Ramsey\\Uuid\\Uuid; class UserRepositoryImpl extends AggregateRepository implements UserRepository { public function __construct(EventStore $eventStore) { \/\/We inject a Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator that can handle our AggregateRoots parent::__construct( $eventStore, AggregateType::fromAggregateRootClass('My\\Model\\User'), new AggregateTranslator(), null, \/\/We don't use a snapshot store in the example null, \/\/Also a custom stream name is not required true \/\/But we enable the \"one-stream-per-aggregate\" mode ); } public function save(User $user): void { $this-&gt;saveAggregateRoot($user); } public function get(Uuid $uuid): ?User { return $this-&gt;getAggregateRoot($uuid-&gt;toString()); } } } namespace { \/\/Set up an EventStore with an InMemoryAdapter (Only useful for testing, persistent implementations of ProophEventStore are available) use My\\Infrastructure\\UserRepositoryImpl; use My\\Model\\User; use Prooph\\Common\\Event\\ActionEvent; use Prooph\\Common\\Event\\ProophActionEventEmitter; use Prooph\\EventStore\\InMemoryEventStore; use Prooph\\EventStore\\TransactionalActionEventEmitterEventStore; $eventStore = new TransactionalActionEventEmitterEventStore( new InMemoryEventStore(), new ProophActionEventEmitter() ); \/\/Now we set up our user repository and inject the EventStore \/\/Normally this should be done in an IoC-Container and the receiver of the repository should require My\\Model\\UserRepository $userRepository = new UserRepositoryImpl($eventStore); \/\/Ok lets start a new transaction and create a user $eventStore-&gt;beginTransaction(); $user = User::nameNew('John Doe'); \/\/Before we save let's attach a listener to check that the UserWasCreated event is recorded $eventStore-&gt;attach( TransactionalActionEventEmitterEventStore::EVENT_CREATE, function (ActionEvent $event): void { foreach ($event-&gt;getParam('stream')-&gt;streamEvents() as $streamEvent) { echo sprintf( 'Event with name %s was recorded. It occurred on %s UTC \/\/\/ ', $streamEvent-&gt;messageName(), $streamEvent-&gt;createdAt()-&gt;format('Y-m-d H:i:s') ) . PHP_EOL; } }, -1000 ); $userRepository-&gt;save($user); \/\/Let's make sure the transaction is written $eventStore-&gt;attach( TransactionalActionEventEmitterEventStore::EVENT_COMMIT, function (ActionEvent $event): void { echo 'Transaction commited' . PHP_EOL; }, -1000 ); $eventStore-&gt;commit(); $userId = $user-&gt;userId(); unset($user); \/\/Ok, great. Now let's see how we can grab the user from the repository and change the name \/\/First we need to start a new transaction $eventStore-&gt;beginTransaction(); \/\/The repository automatically tracks changes of the user... $loadedUser = $userRepository-&gt;get($userId); $loadedUser-&gt;changeName('Max Mustermann'); \/\/Before we save let's attach a listener again on appendTo to check that the UserWasRenamed event is recorded $eventStore-&gt;attach( TransactionalActionEventEmitterEventStore::EVENT_APPEND_TO, function (ActionEvent $event): void { foreach ($event-&gt;getParam('streamEvents') as $streamEvent) { echo sprintf( 'Event with name %s was recorded. It occurred on %s UTC \/\/\/ ', $streamEvent-&gt;messageName(), $streamEvent-&gt;createdAt()-&gt;format('Y-m-d H:i:s') ) . PHP_EOL; } }, -1000 ); $userRepository-&gt;save($loadedUser); \/\/... so we only need to commit the transaction and the UserWasRenamed event should be recorded \/\/(check output of the previously attached listener) $eventStore-&gt;commit(); } "},{"id":"\/event-sourcing\/intro.html#4-1-3","title":"Prooph Event Store Integration","content":"prooph\/event-sourcing ships with a prooph\/event-store AggregateTranslator to connect the store with the bundled AggregateRoot."},{"id":"\/event-sourcing\/repositories.html#4-2","title":"Working with Repositories","content":"Repositories typically connect your domain model with the persistence layer (part of the infrastructure). Following DDD suggestions your domain model should be database agnostic. An event store is of course some kind of database so you are likely looking for a third-party event store that gets out of your way.The good news is: You've found one!But you need to get familiar with the concept. So you're pleased to read this document and follow the example. Afterwards you should be able to integrate prooph\/event-store into your infrastructure without coupling it with your model."},{"id":"\/event-sourcing\/repositories.html#4-2-1","title":"Event Sourced Aggregates","content":"We assume that you want to work with event sourced aggregates. If you are not sure what we are talking about please refer to the great educational project Buttercup.Protects by Mathias Verraes. prooph\/event-store does not include base classes or traits to add event sourced capabilities to your aggregates.Sounds bad? It isn't!It is your job to write something like Buttercup.Protects for your model. Don't be lazy in this case.The event store doesn't know anything about aggregates. It is just interested in Prooph\\Common\\Messaging\\Message events. These events are organized in Prooph\\EventStore\\Streams. A repository is responsible for extracting pending events from aggregates and putting them in the correct stream. And the repository must also be able to load persisted events from a stream and reconstitute an aggregate. To provide this functionality the repository makes use of various helper classes explained below."},{"id":"\/event-sourcing\/repositories.html#4-2-2","title":"AggregateType","content":"Each repository is responsible for one \\Prooph\\EventSourcing\\Aggregate\\AggregateType."},{"id":"\/event-sourcing\/repositories.html#4-2-3","title":"AggregateTranslator","content":"To achieve 100% decoupling between layers and\/or contexts you can make use of translation adapters. For prooph\/event-store such a translation adapter is called a Prooph\\EventSourcing\\Aggregate\\AggregateTranslator.The interface requires you to implement 5 methods: extractAggregateId extractAggregateVersion extractPendingStreamEvents reconstituteAggregateFromHistory replayStreamEvents To make your life easier prooph\/event-sourcing ships with a \\Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator which implements the interface."},{"id":"\/event-sourcing\/repositories.html#4-2-4","title":"Snapshot Store","content":"A repository can be set up with a snapshot store to speed up loading of aggregates.You need to install Prooph SnapshotStore and a persistable implementation of it, like pdo-snapshot-store or mongodb-snapshot-store."},{"id":"\/event-sourcing\/repositories.html#4-2-5","title":"Event Streams","content":"An event stream can be compared with a table in a relational database (and in case of the pdo-event-store it is a table). By default the repository puts all events of all aggregates (no matter the type) in a single stream called event_stream. If you wish to use another name, you can pass a custom Prooph\\EventStore\\StreamName to the repository. This is especially useful when you want to have an event stream per aggregate type, for example store all user related events in a user_stream.The repository can also be configured to create a new stream for each new aggregate instance. You'll need to turn the last constructor parameter oneStreamPerAggregate to true to enable the mode. If the mode is enabled the repository builds a unique stream name for each aggregate by using the AggregateType and append the aggregateId of the aggregate. The stream name for a new Acme\\User with id 123 would look like this: Acme\\User-123.Depending on the event store implementation used the stream name is maybe modified by the implementation to replace or removed non supported characters. Check your event store implemtation of choice for details. You can also override AggregateRepository::determineStreamName to apply a custom logic for building the stream name."},{"id":"\/event-sourcing\/repositories.html#4-2-6","title":"Wiring It Together","content":"Best way to see a repository in action is by looking at the \\ProophTest\\EventSourcing\\Aggregate\\AggregateRepositoryTest."},{"id":"\/event-sourcing\/repositories.html#4-2-6-1","title":"Set Up","content":"$this-&gt;repository = new AggregateRepository( $this-&gt;eventStore, AggregateType::fromAggregateRootClass('ProophTest\\EventSourcing\\Mock\\User'), new AggregateTranslator() ); $this-&gt;eventStore-&gt;create(new Stream(new StreamName('event_stream'), new ArrayIterator())); Notice the injected dependencies! Snapshot store, stream name and stream mode are optional and not injected for all tests. Therefore stream name defaults to event_stream and the repository appends all events to this stream. For the test cases we also create the stream on every run. In a real application you need to do this only once.\/** * @test *\/ public function it_adds_a_new_aggregate(): void { $user = User::create('John Doe', 'contact@prooph.de'); $this-&gt;repository-&gt;saveAggregateRoot($user); $fetchedUser = $this-&gt;repository-&gt;getAggregateRoot( $user-&gt;getId()-&gt;toString() ); $this-&gt;assertInstanceOf('ProophTest\\EventStore\\Mock\\User', $fetchedUser); $this-&gt;assertNotSame($user, $fetchedUser); $this-&gt;assertEquals('John Doe', $fetchedUser-&gt;name()); $this-&gt;assertEquals('contact@prooph.de', $fetchedUser-&gt;email()); } In the first test case you can see how an aggregate (the user entity in this case) can be added to the repository.\/** * @test *\/ public function it_tracks_changes_of_aggregate(): void { $user = User::create('John Doe', 'contact@prooph.de'); $this-&gt;repository-&gt;saveAggregateRoot($user); $fetchedUser = $this-&gt;repository-&gt;getAggregateRoot( $user-&gt;getId()-&gt;toString() ); $this-&gt;assertNotSame($user, $fetchedUser); $fetchedUser-&gt;changeName('Max Mustermann'); $this-&gt;repository-&gt;saveAggregateRoot($fetchedUser); $fetchedUser2 = $this-&gt;repository-&gt;getAggregateRoot( $user-&gt;getId()-&gt;toString() ); $this-&gt;assertNotSame($fetchedUser, $fetchedUser2); $this-&gt;assertEquals('Max Mustermann', $fetchedUser2-&gt;name()); } Here we first add the user, then load it with the help of the repository and finally we change the user entity. The change causes a UserNameChanged event.Note the identity map is cleared after each transaction commit. You may notice the assertNotSame checks in the test. The repository keeps an aggregate only in memory as long as the transaction is active. Otherwise multiple long-running processes dealing with the same aggregate would run into concurrency issues very fast.The test case has some more tests including snapshot usage and working with different stream names \/ strategies. Just browse through the test methods for details."},{"id":"\/event-sourcing\/repositories.html#4-2-7","title":"Aggregate Type Mapping","content":"It's possible to map an aggregate type user to an aggregate root class like My\\Model\\User. To do that, add the aggregate type mapping to your repository and use the provided aggregate type. The aggregate type mapping is implemented in the AggregateType class like this:$aggregateType = AggregateType::fromMapping(['user' =&gt; MyUser::class]); Example configuration:[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; [ 'user' =&gt; MyUser::class, \/\/ &lt;- custom name to class mapping ], 'aggregate_translator' =&gt; 'user_translator', ], ], ], ], ] "},{"id":"\/event-sourcing\/repositories.html#4-2-8","title":"Loading of thousands aggregates","content":"If you need to load thousands of aggregates for reading only, your memory can be exhausted, because the AggregateRepository uses an identity map. So every loaded aggregate is stored there, unless a commit is executed. If you have a read only process, you should consider to clear the identity map at some time. This can be done by calling clearIdentityMap().$thousandsOfAggregateIds = [ \/\/ lots of ids here ]; $number = 0; foreach ($thousandsOfAggregateIds as $aggregateId) { $aggregate = $this-&gt;repository-&gt;getAggregateRoot($aggregateId); $number++; \/\/ do something with the aggregate data e.g. build read model \/\/ clear on every 500th aggregate if (0 === $number % 500) { $this-&gt;repository-&gt;clearIdentityMap(); } } "},{"id":"\/event-sourcing\/snapshots\/intro.html#4-3-1","title":"Introduction","content":"One of the counter-arguments against Event-Sourcing you might heard about is that replaying events takes too much time.Replaying 20 events for an aggregate is fast, 50 is ok, but 100 events and more become slow depending on the data of the events and the operations needed to replay them. A DDD rule of thumb says aggregates should be kept small. Keeping that in mind you should be fine with 50 events per aggregate in most cases."},{"id":"\/event-sourcing\/snapshots\/intro.html#4-3-1-1","title":"But my aggregates record tons of events!","content":"If aggregate reconstitution gets slow you can add an additional layer to the system which is capable of providing aggregate snapshots.Choose one of the Prooph\\SnapshotStore\\* implementations and combine it with prooph\/snapshotter to take snapshots. Inject the snapshot store into an aggregate repository and the repository will use the snapshot store to speed up aggregate loading.Note: All SnapshotStores ship with interop factories to ease set up.More information about snapshots and how to configure them can be found on the next pages."},{"id":"\/event-sourcing\/snapshots\/snapshotter\/snapshots.html#4-3-2-1","title":"Snapshotter","content":"Snapshot tool for the prooph event-store. Take aggregate snapshots with ease."},{"id":"\/event-sourcing\/snapshots\/snapshotter\/snapshots.html#4-3-2-1-1","title":"Installation","content":"composer require prooph\/snapshotter "},{"id":"\/event-sourcing\/snapshots\/snapshotter\/snapshots.html#4-3-2-1-2","title":"Snapshots via Projection","content":"There are two projections shipped with this package: CategorySnapshotProjection StreamSnapshotProjection "},{"id":"\/event-sourcing\/snapshots\/snapshotter\/snapshots.html#4-3-2-1-3","title":"CategorySnapshotProjection","content":"Use this one, if you are using one stream per aggregate, so when you have two users with ids 123 and 234 the event streams are named user-123 and user-234, in this case you need to create the snapshots by querying the category user."},{"id":"\/event-sourcing\/snapshots\/snapshotter\/snapshots.html#4-3-2-1-4","title":"StreamSnapshotProjection","content":"Use this one, if you are using one stream for all aggregates, so when you have two users with ids 123 and 234 the event stream is simply user for both of them, in this case you need to create the snapshots by querying the stream user."},{"id":"\/event-sourcing\/snapshots\/snapshotter\/snapshots.html#4-3-2-1-5","title":"Usage","content":"You need to create a simple script, that might look similar to this and run it in background. With the help of docker-containers or supervisord you can keep the script alive, if it dies.&lt;?php $container = include 'container.php'; $projectionManager = $container-&gt;get(\\Prooph\\EventStore\\Projection\\ProjectionManager::class); $projection = $projectionManager-&gt;createReadModelProjection( 'user-snapshots', new \\Prooph\\Snapshotter\\SnapshotReadModel( $container-&gt;get('user_repository'), new \\Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator(), $container-&gt;get(\\Prooph\\SnapshotStore\\SnapshotStore::class), [ 'user', ] ) ); $categorySnapshotProjection = new \\Prooph\\Snapshotter\\CategorySnapshotProjection($projection, 'user'); $categorySnapshotProjection-&gt;run(); \/\/ or $streamSnapshotProjection = new \\Prooph\\Snapshotter\\StreamSnapshotProjection($projection, 'user'); $streamSnapshotProjection-&gt;run(); "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/snapshot_store.html#4-3-3-1","title":"Overview","content":"Simple and lightweight snapshot store that works together with prooph\/event-sourcing to speed up loading of aggregates."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/snapshot_store.html#4-3-3-1-1","title":"Installation","content":"composer require prooph\/snapshot-store "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/snapshot_store.html#4-3-3-1-2","title":"Creating snapshots from event streams","content":"This feature is provided by the prooph\/snapshotter package. Please refer to the docs of the package to learn more about it.Also choose one of the Prooph\\*SnapshotStore to take snapshots. Inject the snapshot store into an aggregate repository and the repository will use the snapshot store to speed up aggregate loading.Our example application proophessor-do contains a snapshotting tutorial."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/snapshot_store.html#4-3-3-1-3","title":"Using a different Serializer.","content":"By default prooph uses PHP's own serialise and unserialize methods. These may not suite your needs so as of v1.1 of the snapshot store you can use a custom serialiser.You can use the provided CallbackSerializer to do this.&lt;?php new PdoSnapshotStore( $connection, $config['snapshot_table_map'], $config['default_snapshot_table_name'], new CallbackSerializer('igbinary_serialize', 'igbinary_unserialize') ); If you are using the interop factories all you have to do is create a Factory for Prooph\\SnapshotStore\\Serializer and add that as dependency;&lt;?php return [ 'dependencies' =&gt; [ 'factories' =&gt; [ \\Prooph\\SnapshotStore\\Serializer::class =&gt; My\\CallbackSerializerFactory::class, ], ], ]; Note: All SnapshotStores ship with interop factories to ease set up."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/snapshot_store.html#4-3-3-1-4","title":"Composite Snapshot Store","content":"This component ships with a composite snapshot store, that aggregates multiple snapshot stores. When asked to save a snapshot or removeAll, it will call the method in all aggregated snapshot stores. If you try to get a snapshot from the composite, it will ask each snapshot store for the snapshot and returns the first snapshot found or null.This is especially useful to combine a memcached snapshot store for high speed with a fallback like pdo or mongodb.Example:&lt;?php $snapshotStore1 = new MemcachedSnapshotStore(); $snapshotStore2 = new MongoDbSnapshotStore(); $snapshotStore = new CompositeSnapshotStore($snapshotStore1, $snapshotStore2); "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/snapshot_store.html#4-3-3-1-5","title":"Usage","content":"Using Prooph Event-Sourcing you need to install Prooph Snapshotter. Check the documentation there on how to use it.Using Prooph Micro the usage is a simple php function."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/intro.html#4-3-3-2-1","title":"Overview","content":"PDO implementation of snapshot store"},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/intro.html#4-3-3-2-1-1","title":"Installation","content":"composer require prooph\/pdo-snapshot-store "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/intro.html#4-3-3-2-1-2","title":"Setup","content":"The PDO SnapshotStore is currently tested with 3 backends, MariaDB, MySQL and Postgres.In order to use it, you need have a database and create one (or multitple) snapshot tables.For MySQL and MariaDB see: scripts\/mysql_snapshot_table.sql For Postgres see: scripts\/postgres_snapshot_table.sql"},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/intro.html#4-3-3-2-1-3","title":"Disable transaction handling","content":"You can configure the snapshot store to disable transaction handling completely. In order to do this, set the last parameter in the constructor to true (or configure your interop config factory accordingly, key is disable_transaction_handling).Enabling this feature will disable all transaction handling and you have to take care yourself to start, commit and rollback transactions.Note: This could lead to problems using the snapshot store, if you did not manage to handle the transaction handling accordingly. This is your problem and we will not provide any support for problems you encounter while doing so."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/interop_factories.html#4-3-3-2-2","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/interop_factories.html#4-3-3-2-2-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/interop_factories.html#4-3-3-2-2-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/pdo_snapshot_store\/interop_factories.html#4-3-3-2-2-1-2","title":"PdoSnapshotStoreFactory","content":"Sample configuration:[ 'prooph' =&gt; [ 'pdo_snapshot_store' =&gt; [ 'default' =&gt; [ 'connection_service' =&gt; 'my_pdo_connection', \/\/&lt;-- service name of your pdo connection 'default_snapshot_table_name' =&gt; 'snapshots', \/\/&lt;-- table name of your snapshots, defaults to `snapshots` 'snapshot_table_map' =&gt; [ \/\/&lt;-- Array with key = aggregate type, value = snapshot table name, defaults to empty array 'My\\AggregateOne' =&gt; 'one_snapshots', 'My\\AggregteTwo' =&gt; 'two_snapshots', ], 'serializer' =&gt; 'My\\Serializer' \/\/&lt;-- optional, service name of a custom serializer ], ], ], ] "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/intro.html#4-3-3-3-1","title":"Overview","content":"MongoDB implementation of snapshot store"},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/intro.html#4-3-3-3-1-1","title":"Installation","content":"composer require prooph\/mongodb-snapshot-store "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/intro.html#4-3-3-3-1-2","title":"Requirements","content":" PHP 7.1 MongoDB &gt;= 3.4 PHP MongoDB Extension "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/interop_factories.html#4-3-3-3-2","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/interop_factories.html#4-3-3-3-2-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/interop_factories.html#4-3-3-3-2-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/mongodb_snapshot_store\/interop_factories.html#4-3-3-3-2-1-2","title":"MongoDbSnapshotStoreFactory","content":"Sample configuration:[ 'prooph' =&gt; [ 'mongodb_snapshot_store' =&gt; [ 'default' =&gt; [ 'mongo_client_service' =&gt; 'my_mongo_connection', \/\/&lt;-- service name of your mongo client 'db_name' =&gt; 'test_db', \/\/&lt;-- database name 'default_snapshot_grid_fs_name' =&gt; 'snapshots', \/\/&lt;-- grid fs name of your snapshots, defaults to `snapshots` 'snapshot_grid_fs_map' =&gt; [ \/\/&lt;-- Array with key = aggregate type, value = snapshot grid fs name, defaults to empty array 'My\\AggregateOne' =&gt; 'one_snapshots', 'My\\AggregteTwo' =&gt; 'two_snapshots', ], 'read_concern' =&gt; 'local', \/\/&lt;-- read concern options, defaults to `local`, 'write_concern' =&gt; [ \/\/&lt;-- write concern options, default listed below 'w' =&gt; 1, 'wtimeout' =&gt; 0, \/\/ How long to wait (in milliseconds) for secondaries before failing. 'journal' =&gt; false, \/\/ Wait until mongod has applied the write to the journal. ], 'serializer' =&gt; 'My\\Serializer' \/\/&lt;-- optional, service name of a custom serializer ], ], ], ] "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/intro.html#4-3-3-4-1","title":"Overview","content":"Memcached implementation of snapshot store"},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/intro.html#4-3-3-4-1-1","title":"Installation","content":"composer require prooph\/memcached-snapshot-store "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/intro.html#4-3-3-4-1-2","title":"Requirements","content":" ext-memcached ^3.0 "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/interop_factories.html#4-3-3-4-2","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/interop_factories.html#4-3-3-4-2-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/interop_factories.html#4-3-3-4-2-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/memcached_snapshot_store\/interop_factories.html#4-3-3-4-2-1-2","title":"MemcachedSnapshotStoreFactory","content":"Sample configuration:[ 'prooph' =&gt; [ 'memcached_snapshot_store' =&gt; [ 'default' =&gt; [ 'connection_service' =&gt; 'my_memcached_connection', \/\/&lt;-- service name of your memcached connection 'serializer' =&gt; 'My\\Serializer' \/\/&lt;-- optional, service name of a custom serializer ], ], ], ] "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/intro.html#4-3-3-5-1","title":"Overview","content":"ArangoDB implementation of snapshot store."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/intro.html#4-3-3-5-1-1","title":"Installation","content":"composer require prooph\/arangodb-snapshot-store "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/intro.html#4-3-3-5-1-2","title":"Requirements","content":" PHP 7.1 ArangoDB server &gt;= 3.2 "},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/interop_factories.html#4-3-3-5-2","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/interop_factories.html#4-3-3-5-2-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/interop_factories.html#4-3-3-5-2-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-sourcing\/snapshots\/snapshot_store\/arangodb_snapshot_store\/interop_factories.html#4-3-3-5-2-1-2","title":"ArangoDBSnapshotStoreFactory","content":"See Prooph\\SnapshotStore\\ArangoDb\\Container\\ArangoDBSnapshotStoreFactory for config options.Sample configuration:[ 'prooph' =&gt; [ 'arangodb_snapshot_store' =&gt; [ 'default' =&gt; [ 'arangodb_client_service' =&gt; 'my_arangodb_client_connection', \/\/&lt;-- service name of your ArangoDB connection ], ], ], ] "},{"id":"\/event-sourcing\/inheritance.html#4-4","title":"Inheritance with Aggregate Roots","content":"If you want to make inheritance work with aggregate roots using a common repository for all subtypes, this can also be achieved very easily."},{"id":"\/event-sourcing\/inheritance.html#4-4-1","title":"An example","content":"Consider the following use case:abstract class User extends \\Prooph\\EventSourcing\\AggregateRoot { protected $name; protected $email; public function name(): string { return $this-&gt;name; } public function email(): string { return $this-&gt;email; } protected function apply(AggregateChanged $e): void { if ($e instanceof UserWasRegisterd) { $this-&gt;name = $e-&gt;name(); $this-&gt;email = $e-&gt;email(); } } } class Admin extends User { public static function register(string $name, string $email): Admin { $self = new self(); $self-&gt;recordThat(UserWasRegisterd::withData('admin', $name, $email); return $self; } } class Member extends User { public static function register(string $name, string $email): Member { $self = new self(); $self-&gt;recordThat(UserWasRegisterd::withData('member', $name, $email); return $self; } } So in order to make this work, you need 3 small changes in your application."},{"id":"\/event-sourcing\/inheritance.html#4-4-2","title":"Step 1: Create a UserAggregateTranslator","content":"final class UserAggregateTranslator extends \\Prooph\\EventSourcing\\EventStoreIntegration\\AggregateTranslator { \/** * @param \\Prooph\\EventStore\\Aggregate\\AggregateType $aggregateType * @param \\Iterator $historyEvents * @return object reconstructed AggregateRoot *\/ public function reconstituteAggregateFromHistory( \\Prooph\\EventStore\\Aggregate\\AggregateType $aggregateType, \\Iterator $historyEvents ) { $aggregateRootDecorator = $this-&gt;getAggregateRootDecorator(); $firstEvent = $historyEvents-&gt;current(); $type = $firstEvent-&gt;type(); if ($type === 'admin') { return $aggregateRootDecorator-&gt;fromHistory(Admin::class, $historyEvents); } elseif ($type === 'member') { return $aggregateRootDecorator-&gt;fromHistory(Member::class, $historyEvents); } } } "},{"id":"\/event-sourcing\/inheritance.html#4-4-3","title":"Step 2: Change the assertion method in the EventStoreUserCollection","content":"final class EventStoreUserCollection extends \\Prooph\\EventStore\\Aggregate\\AggregateRepository { public function save(User $user): void { $this-&gt;saveAggregateRoot($user); } public function get(UserId $userId): ?User { return $this-&gt;getAggregateRoot($userId-&gt;toString()); } protected function assertAggregateType($eventSourcedAggregateRoot) { \\Assert\\Assertion::isInstanceOf($eventSourcedAggregateRoot, User::class); } } "},{"id":"\/event-sourcing\/inheritance.html#4-4-4","title":"Step 3: Make use of your custom AggregateTranslator","content":"final class EventStoreUserCollectionFactory { public function __invoke(ContainerInterface $container): EventStoreUserCollection { return new EventStoreUserCollection( $container-&gt;get(EventStore::class), AggregateType::fromAggregateRootClass(User::class), new UserAggregateTranslator() ); } } If you use the provided container factory (\\Prooph\\EventStore\\Container\\Aggregate\\AbstractAggregateRepositoryFactory) then you can also just change the aggregate_translator key in your config to point to the new UserAggregateTranslator and register the UserAggregateTranslator in your container.see also: http:\/\/www.sasaprolic.com\/2016\/02\/inheritance-with-aggregate-roots-in.html"},{"id":"\/event-sourcing\/inheritance.html#4-4-5","title":"Alternative to AggregateRoot inheritance","content":"Abstract Prooph\\EventSourcing\\AggregateRoot class provides a solid basis for your aggregate roots, however, it is not mandatory. Two traits, Prooph\\EventSourcing\\Aggregate\\EventProducerTrait and Prooph\\EventSourcing\\Aggregate\\EventSourcedTrait, together provide exactly the same functionality. EventProducerTrait is responsible for event producing side of Event Sourcing and might be used independently of EventSourcedTrait when you are not ready to start with full event sourcing but still want to get the benefit of design validation and audit trail provided by Event Sourcing. Forcing all changes to be applied internally via event sourcing will ensure events data consistency with the state and will make it easier to switch to full event sourcing later on. EventSourcedTrait is responsible for restoring state from event stream, it should be used together with EventProducerTrait as normally you will not be applying events not produced by that aggregate root. Default aggregate translator uses AggregateRootDecorator to access protected methods of Prooph\\EventSourcing\\AggregateRoot descendants, you will need to switch to Prooph\\EventSourcing\\EventStoreIntegration\\ClosureAggregateTranslator for aggregate roots using traits."},{"id":"\/event-sourcing\/interop_factories.html#4-5","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/event-sourcing\/interop_factories.html#4-5-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/event-sourcing\/interop_factories.html#4-5-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/event-sourcing\/interop_factories.html#4-5-1-2","title":"AggregateRepositoryFactory","content":"To ease set up of repositories for your aggregate roots prooph\/event-store also ships with a Prooph\\EventStore\\Container\\Aggregate\\AbstractAggregateRepositoryFactory. It is an abstract class implementing the container-interop RequiresContainerId interface. The containerId method itself is not implemented in the abstract class. You have to extend it and provide the container id because each aggregate repository needs a slightly different configuration and therefore needs its own config key.Note: You can have a look at the ProophTest\\EventStore\\Mock\\RepositoryMockFactory. It sounds more complex than it is.Let's say we have a repository factory for a User aggregate root. We use user_repository as container id and add this configuration to our application configuration:[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ \/\/&lt;-- here the container id is referenced 'repository_class' =&gt; MyUserRepository::class, \/\/&lt;-- FQCN of the repository responsible for the aggregate root 'aggregate_type' =&gt; MyUser::class, \/\/&lt;-- The aggregate root FQCN the repository is responsible for 'aggregate_translator' =&gt; 'user_translator', \/\/&lt;-- The aggregate translator must be available as service in the container ], ], ], ], ] If you want to speed up loading of aggregates with a snapshot store then you need to make it available as service in the container and use the configuration to let the factory inject the snapshot store in the repository.Also you need to install Prooph SnapshotStore and a persistable implementation of it, like pdo-snapshot-store or mongodb-snapshot-store.[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; MyUser::class, 'aggregate_translator' =&gt; 'user_translator', 'snapshot_store' =&gt; 'awesome_snapshot_store' \/\/ &lt;-- SnapshotStore service id ], ], ], ], \/\/ zf3 service manager example to configure snapshot store service below 'dependencies' =&gt; [ 'aliases' =&gt; [ 'awesome_snapshot_store' =&gt; InMemorySnaphotStore::class, ], 'factories' =&gt; [ InMemorySnaphotStore::class =&gt; InvokableFactory::class, ], ], ] You can also configure a custom stream name (default is event_stream):[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; MyUser::class, 'aggregate_translator' =&gt; 'user_translator', 'snapshot_store' =&gt; 'awesome_snapshot_store', \/\/ &lt;-- SnapshotStore service id 'stream_name' =&gt; 'user_stream' \/\/ &lt;-- Custom stream name ], ], ], ], ] Last but not least you can enable the so called \"One-Stream-Per-Aggregate-Mode\":[ 'prooph' =&gt; [ 'event_sourcing' =&gt; [ 'aggregate_repository' =&gt; [ 'user_repository' =&gt; [ 'repository_class' =&gt; MyUserRepository::class, 'aggregate_type' =&gt; MyUser::class, 'aggregate_translator' =&gt; 'user_translator', 'snapshot_store' =&gt; 'awesome_snapshot_store', \/\/ &lt;-- SnapshotStore service id 'one_stream_per_aggregate' =&gt; true \/\/ &lt;-- Enable One-Stream-Per-Aggregate-Mode ], ], ], ], ] "},{"id":"\/event-sourcing\/migration.html#4-6-1","title":"Aggregate Repository","content":"The aggregate repository has a new method saveAggregateRoot($aggregateRoot) which replaces the addAggregateRoot($aggregateRoot) method. Additionally this method has to be called everytime you change an aggregate root, so if you're working with the command bus, you have to update all your handlers and call saveAggregateRoot everywhere.Reason: In the past the aggregate root was automatically updated with the aggregate repository due to the EventStore::commit event hook. The event store does not implement the commit method in all cases now, only the ones implementing the Prooph\\EventStore\\TransactionalEventStore interface. Also not all event stores are needed to trigger action events. Only the ones that are wrapped by Prooph\\EventStore\\ActionEventEmitterEventStore or Prooph\\EventStore\\TransactionalActionEventEmitterEventStore. In order for the repositories to work in all scenarios (where you can also change the used event store implementation in your app) this behaviour has been removed and you always have to call saveAggregateRoot($aggregateRoot) on the aggregate repository yourself."},{"id":"\/event-sourcing\/migration.html#4-6-2","title":"Moved classes","content":"The classes Prooph\\EventStore\\Aggregate\\* are moved from the event-store repository to the event-sourcing repository. Hence the new class name Prooph\\EventSourcing\\Aggregate\\*. This includes the AggregateRepository, AggregateTranslator, AggregateType and AggregateTypeProvider as well as some exception classes.Same goes for Prooph\\EventStore\\Snapshot\\* classes.Reason:The event-store should not know anything about event sourcing at all, it's only a mechanism to store a stream of events. Therefore all those classes are moved."},{"id":"\/event-sourcing\/migration.html#4-6-3","title":"ConfigurableAggregateTranslator","content":"The ConfigurableAggregateTranslator was part of Prooph\\EventStore v6 and has been completely removed. If you want to use something similar (especially when you don't want to extend from Prooph\\EventSourcing\\AggregateRoot) then you can implement the Prooph\\EventSourcing\\Aggregate\\AggregateTranslator interface yourself."},{"id":"\/event-sourcing\/migration.html#4-6-4","title":"Snapshot Store","content":"The snapshot store is now a simple interface, see Prooph\\SnapshotStore\\SnapshotStore. The adapters have all been removed and replaced with different snapshot store implementation, f.e. Prooph\\SnapshotStore\\InMemorySnapshotStore."},{"id":"\/event-sourcing\/migration.html#4-6-5","title":"Aggregate Root","content":"The method apply is now an abstract protected method. The old implementation was:protected function apply(AggregateChanged $e) { $handler = $this-&gt;determineEventHandlerMethodFor($e); if (! method_exists($this, $handler)) { throw new \\RuntimeException(sprintf( 'Missing event handler method %s for aggregate root %s', $handler, get_class($this) )); } $this-&gt;{$handler}($e); } protected function determineEventHandlerMethodFor(AggregateChanged $e) { return 'when' . implode(array_slice(explode('\\\\', get_class($e)), -1)); } and is now replaced by simply:abstract protected function apply(AggregateChanged $e): void; If you want to old behaviour back, you have to implement this yourself.Reason: It's much more performant to have the apply method implemented like:protected function apply(AggregateChanged $e): void { if ($e instanceof Foo) { \/\/ do something } elseif ($e instance of Bar) { \/\/ do something else } else { throw new \\DomainException('Unknown event applied'); } } It's up to you which you prefer and hence there is no default implementation given anymore."}]